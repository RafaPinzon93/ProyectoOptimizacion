{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"nomber",
				"nombreArchivo"
			],
			[
				"nombreAR",
				"nombreArchivoS"
			],
			[
				"nombre",
				"nombreArchivoS	param"
			],
			[
				"ui",
				"uiPrincipal"
			],
			[
				"base",
				"baseDatos	statement"
			],
			[
				"ob",
				"ObtenerDBGUI	class"
			],
			[
				"bas",
				"baseDatosDialog"
			],
			[
				"cam",
				"cambiarDatosDB	function"
			],
			[
				"_",
				"_TRAYECTOS	statement"
			],
			[
				"op",
				"optimizacionFrecuencias"
			],
			[
				"app",
				"append	function"
			],
			[
				"but",
				"buttonBoxOkCancel	statement"
			],
			[
				"UI",
				"Ui_BaseDatosDialog	class"
			],
			[
				"push",
				"pushButtonObtenerDB	statement"
			],
			[
				"Ui",
				"Ui_BaseDatosDialog	class"
			],
			[
				"hora",
				"HORAINICIO	statement"
			],
			[
				"horaI",
				"horaInicio"
			],
			[
				"HORA",
				"lineEditHoraFin"
			],
			[
				"LINE",
				"lineEditHoraFin	statement"
			],
			[
				"line",
				"lineEditHoraInicio	statement"
			],
			[
				"set",
				"setChecked	function"
			],
			[
				"Optimizar",
				"OptimizarThread	class"
			],
			[
				"text",
				"textEditConsole"
			],
			[
				"data",
				"dataReady	function"
			],
			[
				"read",
				"stopReading"
			],
			[
				"tex",
				"textEditConsole	statement"
			],
			[
				"fre",
				"FrecuenciasOptimas	statement"
			],
			[
				"isChe",
				"isChecked	function"
			],
			[
				"TIEMPO",
				"TIEMPOESPERA2BUS	statement"
			],
			[
				"TIEMO",
				"TIEMPOABORDAR	statement"
			],
			[
				"Fa",
				"FACTORPASAJERO	statement"
			],
			[
				"optimi",
				"optimizacionFrecuencias	statement"
			],
			[
				"tiempoE",
				"tiempoEspera2Bus	param"
			],
			[
				"tiempoA",
				"tiempoAbordar	param"
			],
			[
				"capaci",
				"capacidadBuses	param"
			],
			[
				"factor",
				"factorPasajero	param"
			],
			[
				"FAC",
				"FACTORPASAJERO	statement"
			],
			[
				"optim",
				"optimizacionFrecuencias	statement"
			],
			[
				"fin",
				"finTrayecto"
			],
			[
				"generar",
				"generarCSV	function"
			],
			[
				"numero",
				"numeroDemanda	param"
			],
			[
				"obtener",
				"obtenerDatosBase	function"
			],
			[
				"capa",
				"capacidadBuses"
			],
			[
				"numeroEsta",
				"numeroEstacionesC"
			],
			[
				"setVie",
				"setViewMode	function"
			],
			[
				"setview",
				"setViewMode	function"
			],
			[
				"casca",
				"cascadeSubWindows	function"
			],
			[
				"close",
				"closeAllSubWindows	function"
			],
			[
				"pus",
				"pushButton_5	statement"
			],
			[
				"sub",
				"subwindow_2	statement"
			],
			[
				"swb",
				"subwindow	statement"
			],
			[
				"Optim",
				"OptimizacionFrecuencias	class"
			],
			[
				"LABL",
				"label_ResultadoOut	statement"
			],
			[
				"segund",
				"segundoNumeroEdit	statement"
			],
			[
				"seg",
				"segundoNumeroEdit	statement"
			],
			[
				"QFile",
				"QFileDialog	class"
			],
			[
				"file",
				"fileObj	statement"
			],
			[
				"zero",
				"ZeroSpinBox"
			],
			[
				"Z",
				"ZeroSpinBox	class"
			],
			[
				"Qt",
				"QtCore	module"
			],
			[
				"obj",
				"objFunction	function"
			],
			[
				"PASS",
				"pass	keyword"
			],
			[
				"QDouble",
				"QDoubleSpinBox	class"
			],
			[
				"Q",
				"QtCore	module"
			],
			[
				"tiempoTra",
				"tiempoTrayectos"
			],
			[
				"QDia",
				"QDialog	class"
			],
			[
				"horas",
				"horas"
			],
			[
				"propori",
				"_PROPORCIONES"
			],
			[
				"_ti",
				"_TIEMPO_ENTRE_ESTACIONES	statement"
			],
			[
				"trayectosva",
				"trayectosValueF	function"
			],
			[
				"tiempo",
				"tiempoRutas"
			],
			[
				"NUMERO",
				"NUMERORUTAS	statement"
			],
			[
				"tiempos",
				"tiemposTrayectos"
			],
			[
				"TRAYECTOS",
				"trayectosValueF	function"
			],
			[
				"matrices",
				"matricesTransbordo	statement"
			],
			[
				"trayect",
				"trayectoVect	statement"
			],
			[
				"tiemp",
				"tiemposTrayectos	statement"
			],
			[
				"tr",
				"trayectos	statement"
			],
			[
				"cr",
				"crearHilo	function"
			],
			[
				"user",
				"userName	statement"
			],
			[
				"U",
				"Usuarios	statement"
			],
			[
				"User",
				"UserProcess	class"
			],
			[
				"run",
				"runBool	statement"
			],
			[
				"__init__",
				"__init__	function"
			],
			[
				"__",
				"__init__	init"
			],
			[
				"threading",
				"Threading	module"
			],
			[
				"use",
				"userName"
			],
			[
				"pas",
				"Passw	statement"
			],
			[
				"obte",
				"obtenerDatosBase	function"
			],
			[
				"indt",
				"indT	forflow"
			],
			[
				"matr",
				"matrizSecuencia	statement"
			],
			[
				"finT",
				"finTrayectoArray	statement"
			],
			[
				"matTr",
				"matTransbordoT"
			],
			[
				"matrice",
				"matricesTiempo	statement"
			],
			[
				"matric",
				"matricesTiempo	statement"
			],
			[
				"estacion",
				"estacionTransbordo	statement"
			],
			[
				"estaciones",
				"estacionesDict	statement"
			],
			[
				"secuencia",
				"secuenciasA"
			],
			[
				"secue",
				"secuenciasA	statement"
			],
			[
				"mat",
				"matProporcion	statement"
			],
			[
				"ma",
				"matProporcion	statement"
			],
			[
				"sor",
				"sort_keys	param"
			],
			[
				"json",
				"jsonFile	function"
			],
			[
				"setW",
				"setWindowFlags	function"
			],
			[
				"try",
				"try	Try/Except"
			],
			[
				"idtra",
				"idTrayectosNP"
			],
			[
				"idTr",
				"idTrayectosNP	statement"
			],
			[
				"index",
				"indexT	forflow"
			],
			[
				"trayectos",
				"trayectosValue	statement"
			],
			[
				"tra",
				"trayectoVueltaValue	statement"
			],
			[
				"traye",
				"trayectoVuelta	statement"
			],
			[
				"trayecto",
				"trayectoValue	forflow"
			],
			[
				"ind",
				"indexR"
			],
			[
				"tray",
				"trayRuta	statement"
			],
			[
				"esta",
				"estacionesId	statement"
			],
			[
				"trayectoI",
				"trayectoIdaValue	statement"
			],
			[
				"trayectI",
				"trayectoIdaValue	statement"
			],
			[
				"obten",
				"obtenerDatosBase	function"
			],
			[
				"Ruta",
				"RutasFantasmas"
			],
			[
				"list",
				"listEstac	statement"
			],
			[
				"shee",
				"sheet2	statement"
			],
			[
				"cell",
				"cell_type	function"
			],
			[
				"valores",
				"valoresExel"
			],
			[
				"valor",
				"valoresCast"
			],
			[
				"valore",
				"valoresExel"
			],
			[
				"obj_",
				"obj_ruleTest"
			],
			[
				"Esta",
				"EstacionesBaseDatosDict	statement"
			],
			[
				"matri",
				"matricesTransbordoNP	statement"
			]
		]
	},
	"buffers":
	[
		{
			"file": "modeloOptimizacionV4.1.py",
			"settings":
			{
				"buffer_size": 82889,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/rafapinzon/Downloads/Pyevolve-0.6rc1/pyevolve/GSimpleGA.py",
			"settings":
			{
				"buffer_size": 28674,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/rafapinzon/Downloads/Pyevolve-0.6rc1/pyevolve/GPopulation.py",
			"settings":
			{
				"buffer_size": 13859,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/rafapinzon/MEGA/U/Progra/Python/Python GUI Development with Qt Tutorial/Tutorial5InterfazBasica.py",
			"settings":
			{
				"buffer_size": 1775,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/rafapinzon/MEGA/U/Progra/Python/Python GUI Development with Qt Tutorial/SumarApp.py",
			"settings":
			{
				"buffer_size": 851,
				"line_ending": "Unix",
				"name": "SumarApp.py"
			}
		},
		{
			"file": "/home/rafapinzon/MEGA/U/Progra/Python/MyNewGUI/GUI_App.py",
			"settings":
			{
				"buffer_size": 4927,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/rafapinzon/MEGA/U/Progra/Python/MyNewGUI/GUI_App_Threads.py",
			"settings":
			{
				"buffer_size": 5788,
				"line_ending": "Unix"
			}
		},
		{
			"file": "archivos/horariosOpt-modeloOptimizacionV5.py-.json",
			"settings":
			{
				"buffer_size": 1162424,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/rafapinzon/MEGA/U/Progra/Python/Python GUI Development with Qt Tutorial/AppMultipleWindows.py",
			"settings":
			{
				"buffer_size": 2177,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/rafapinzon/MEGA/U/Progra/Python/Python GUI Development with Qt Tutorial/tutorialSumar.py",
			"settings":
			{
				"buffer_size": 2818,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/rafapinzon/MEGA/U/Progra/Python/Python GUI Development with Qt Tutorial/frameMultipleWindow.py",
			"settings":
			{
				"buffer_size": 5590,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/rafapinzon/MEGA/U/Progra/Python/MyNewGUI/GUIframework.py",
			"settings":
			{
				"buffer_size": 15088,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "# -*- coding: utf-8 -*-\nfrom __future__ import division\nimport numpy as np\nimport MySQLdb\nimport json\nimport datetime\nimport copy_reg\nimport types\n\nfrom scipy import optimize\n\nfrom pyevolve import G1DList, GSimpleGA, Selectors\nfrom pyevolve import Initializators, Mutators, Consts\n\nimport inspect, os, sys\n\n\nnp.set_printoptions(threshold=np.nan)\nnp.set_printoptions(linewidth=200)\noldSettings = np.seterr(divide='ignore', invalid='ignore')\nnp.seterr(**oldSettings)\n\ndef _pickle_method(m):\n    if m.im_self is None:\n        return getattr, (m.im_class, m.im_func.func_name)\n    else:\n        return getattr, (m.im_self, m.im_func.func_name)\n\ncopy_reg.pickle(types.MethodType, _pickle_method)\n\nclass OptimizacionFrecuencias(object):\n    \"\"\"\n    Clase donde estan las funciones requeridas y las variables para optimizar las frecuencias\n\n    Parametros\n    ----------\n        - numeroDemanda: Numero de demanda con la que se llenara la matriz de demanda.\n        - factorPasajero: Factor de peso del pasajero.\n        - factorOperador: Factor de peso del operador.\n        - capacidadBuses: Capacidad total de los buses.\n        - tiempoAbordar: Tiempo promedio para abordar los Buses.\n        - tiempoEspera2Bus: Tiempo promedio espera de segundo Bus.\n        - horaInicio: Hora de inicio de servicios.\n        - horaFin: Hora de fin de servicios.\n        - numeroRutas: Numero de Rutas.\n        - numeroEstacionesC: Numero de Estaciones.\n        - frecuenciasOptimas: Lista con el valor de la frecuencia optima para cada ruta.\n        - finTrayecto: Lista con las estaciones finales disponibles de todas las rutas.\n\n    \"\"\"\n    def __init__(self, numeroDemanda = 2, factorPasajero = 100, factorOperador = 100,\n                 capacidadBuses = 150, tiempoAbordar = 1/60.0, tiempoEspera2Bus = 1,\n                 horaInicio = 5, horaFin = 23, numeroRutas = 3, numeroEstacionesC = 15,\n                 frecuenciasOptimas = [0.588608646066, 0.064516141848, 0.487587969109],\n                 finTrayecto = [11,0], transbordosM = None):\n\n        self.FACTORPASAJERO = factorPasajero  # Factor de peso del pasajero\n        self.FACTOROPERADEOR = factorOperador  # Factor de peso del operador\n        self.CAPACIDADBUSES  = capacidadBuses # Capacidad total de los buses\n        self.TIEMPOABORDAR = tiempoAbordar\n        self.TIEMPOESPERA2BUS = tiempoEspera2Bus\n        # self.NUMERODEMANDA = 12\n        self.NUMERODEMANDA = numeroDemanda\n\n        self.HORAINICIO = horaInicio\n        self.HORAFIN = horaFin\n\n        self.NUMERORUTAS = numeroRutas\n        self.NUMEROESTACIONES = numeroEstacionesC\n        \n        self.FrecuenciasOptimas = frecuenciasOptimas\n\n        \n        _TIEMPO_ENTRE_ESTACIONES1 = np.array([[ 0, 2, 4, 6, 6, 8, 8,10,10,12,14,16,12,14,16],\n                                              [ 2, 0, 2, 4, 4, 6, 6, 8, 8,10,12,14,10,12,14],\n                                              [ 4, 2, 0, 2, 2, 4, 4, 6, 6, 8,10,12, 8,10,12],\n                                              [18,14,14, 0,12, 2,10, 4, 8, 6, 8,10, 6, 8,10],\n                                              [ 6, 4, 2, 4, 0, 6, 2, 8, 4, 6, 8,10,10,10,12],\n                                              [14,12,10,12,10, 0, 8, 2, 6, 4, 6, 8, 4, 6, 8],\n                                              [ 8, 6, 4, 6, 2, 8, 0,10, 2, 4, 6, 8,12, 8,10],\n                                              [12,10, 8,10, 8,12, 6, 0, 4, 2, 4, 6, 2, 4, 6],\n                                              [10, 8, 6, 8, 4,10, 2,12, 0, 2, 4, 6,14, 6, 8],\n                                              [12,10, 8,10, 6,12, 4,14, 2, 0, 2, 4,16, 4, 6],\n                                              [14,12,10,12, 8,14, 6,16, 4, 2, 0, 2,18, 2, 4],\n                                              [16,14,12,14,10,16, 8,18, 6, 4, 2, 0,20, 4, 6],\n                                              [10, 8, 6, 8, 8,10,10, 2,12,14,16,18, 0, 2, 4],\n                                              [ 8, 6, 4, 6, 6, 8, 8,10,10,12,14,16,12, 0, 2],\n                                              [ 6, 4, 2, 4, 4, 6, 6, 8, 8,10,12,14,10,12, 0]])\n        _TIEMPO_ENTRE_ESTACIONES2 = np.array([[ 0, 2, 4, 6, 6, 8, 8,10,10,12,14,16,12,14,16],\n                                              [ 2, 0, 2, 4, 4, 6, 6, 8, 8,10,12,14,10,12,14],\n                                              [ 4, 2, 0, 2, 2, 4, 4, 6, 6, 8,10,12, 8,10,12],\n                                              [18,16,12, 0,12, 2,10, 4, 8, 6, 8,10, 6, 8,10],\n                                              [ 6, 4, 2, 4, 0, 6, 2, 8, 4, 6, 8,10,10,12,14],\n                                              [16,14,12,14,10, 0, 8, 2, 6, 4, 6, 8, 4, 6, 8],\n                                              [ 8, 6, 4, 6, 2, 8, 0,10, 2, 4, 6, 8,12, 8,10],\n                                              [14,12,10,12, 8,14, 6, 0, 4, 2, 4, 6, 2, 4, 6],\n                                              [10, 8, 6, 8, 4,10, 2,12, 0, 2, 4, 6,14, 6, 8],\n                                              [12,10, 8,10, 6,12, 4,14, 2, 0, 2, 4,16, 4, 6],\n                                              [10, 8, 6, 8, 8,10, 6,12, 4, 2, 0, 2,14, 2, 4],\n                                              [12,10, 8,10,10,12, 8,14, 6, 4, 2, 0,16, 4, 6],\n                                              [10, 8, 6, 8, 8,10,10, 2,12,14,16,18, 0, 2, 4],\n                                              [ 8, 6, 4, 6, 6, 8, 8,10,10,12,14,16,12, 0, 2],\n                                              [ 6, 4, 2, 4, 4, 6, 6, 8, 8,10,12,14,10,12, 0]])\n        _TIEMPO_ENTRE_ESTACIONES3 = np.array([[ 0, 2, 4, 6, 6, 8, 8,10,10,12,14,16,12,14,16],\n                                              [ 2, 0, 2, 4, 4, 6, 6, 8, 8,10,12,14,10,12,14],\n                                              [ 4, 2, 0, 2, 2, 4, 4, 6, 6, 8,10,12, 8,10,12],\n                                              [16,14,12, 0,14, 2,16, 4,18, 6, 8,10, 6, 8,10],\n                                              [ 6, 4, 2, 4, 0, 6, 2, 8, 4, 6, 8,10,10,12,14],\n                                              [14,12,10,12,12, 0,14, 2,16, 4, 6, 8, 4, 6, 8],\n                                              [ 8, 6, 4, 6, 2, 8, 0,10, 2, 4, 6, 8,12, 8,10],\n                                              [12,10, 8,10,10,12,12, 0,14, 2, 4, 6, 2, 4, 6],\n                                              [10, 8, 6, 8, 4,10, 2,12, 0, 2, 4, 6,14, 6, 8],\n                                              [12,10, 8,10, 6,12, 4,14, 2, 0, 2, 4,16, 4, 6],\n                                              [10, 8, 6, 8, 8,10, 6,12, 4, 2, 0, 2,14, 2, 4],\n                                              [12,10, 8,10,10,12, 8,14, 6, 4, 2, 0,16, 4, 6],\n                                              [10, 8, 6, 8, 8,10,10,12,12,14,16,18, 0, 2, 4],\n                                              [ 8, 6, 4, 6, 6, 8, 8,10,10,12,14,16,12, 0, 2],\n                                              [ 6, 4, 2, 4, 4, 6, 6, 8, 8,10,12,14,10,12, 0]])\n\n        self._TIEMPO_ENTRE_ESTACIONES = [_TIEMPO_ENTRE_ESTACIONES1, _TIEMPO_ENTRE_ESTACIONES2, _TIEMPO_ENTRE_ESTACIONES3]\n\n        tiempoTrayectoIda = [[2.4339788732394365, 3.265845070422535, 3.0809859154929575, 0.9242957746478873, 1.1399647887323943, 1.8177816901408448, 0.8626760563380281, 1.2632042253521125, 0.7702464788732394, 1.3248239436619715, 0.8318661971830986, 2.403169014084507, 2.834507042253521, 0.8318661971830986, 3.820422535211267, 1.3556338028169013, 1.2015845070422535, 1.1707746478873238, 1.509683098591549, 2.7112676056338025],\n                            [2.689964157706094, 3.6093189964157717, 3.4050179211469542, 1.0215053763440864, 1.2598566308243733, 2.1111111111111116, 1.191756272401434, 1.3279569892473122, 0.9534050179211473, 1.6003584229390686, 1.3279569892473122, 1.9408602150537637, 1.2939068100358426, 0.9193548387096778, 1.8387096774193556, 4.222222222222223, 1.4982078853046599, 1.3279569892473122, 1.2939068100358426, 1.6684587813620078, 2.9964157706093197],\n                            [2.7869742198100407, 3.7394843962008144, 3.5278154681139755, 1.0583446404341927, 1.3052917232021708, 2.187245590230665, 1.2347354138398914, 1.3758480325644504, 0.9877883310719133, 1.6580732700135683, 1.3758480325644504, 2.010854816824966, 1.3405698778833108, 0.9525101763907734, 0.9877883310719133]]\n                             \n        tiempoTrayectoVuelta = [[2.1874999999999996, 1.4788732394366195, 1.1091549295774645, 1.232394366197183, 1.3864436619718308, 3.7896126760563376, 0.8626760563380281, 2.7728873239436616, 2.15669014084507, 0.8626760563380281, 1.2015845070422535, 0.9242957746478873, 1.294014084507042, 0.7394366197183098, 1.8485915492957745, 1.232394366197183, 0.8318661971830986, 2.7112676056338025, 2.988556338028168, 2.834507042253521],\n                               [2.4175627240143376, 1.634408602150538, 1.2258064516129035, 1.3620071684587818, 1.5322580645161297, 4.42652329749104, 1.7706093189964165, 2.043010752688173, 1.0555555555555558, 1.3620071684587818, 1.191756272401434, 1.5322580645161297, 1.2939068100358426, 1.9408602150537637, 1.3620071684587818, 0.9193548387096778, 2.9964157706093197, 3.3028673835125457, 3.132616487455198],\n                               [0.7055630936227951, 1.8344640434192672, 2.1166892808683855, 1.0936227951153326, 1.4111261872455902, 1.2347354138398914, 1.587516960651289, 1.3405698778833108, 2.010854816824966, 1.4111261872455902, 0.9525101763907734, 3.104477611940298, 3.421981004070556, 3.245590230664858]]\n\n        self._TiempoDirectoTrayectos = [tiempoTrayectoIda, tiempoTrayectoVuelta]\n\n        \n        #Topologias por rutas y trayectos, teniendo en cuenta viajes 'indirectos'\n        _TOPOLOGIA1 = np.array([[0,1,1,0,1,0,1,0,1,1,1,1,0,0,0],\n                                [0,0,1,0,1,0,1,0,1,1,1,1,0,0,0],\n                                [0,0,0,0,1,0,1,0,1,1,1,1,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,1,0,1,1,1,1,0,1,1],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,1,1,1,1,0,1,1],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,1,1,1,0,1,1],\n                                [0,0,0,0,0,0,0,0,0,0,1,1,0,1,1],\n                                [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]])\n        _TOPOLOGIA2 = np.array([[0,1,1,1,0,1,0,1,0,1,1,1,0,0,0],\n                                [0,0,1,1,0,1,0,1,0,1,1,1,0,0,0],\n                                [0,0,0,1,0,1,0,1,0,1,1,1,0,0,0],\n                                [0,0,0,0,1,1,1,1,1,1,1,1,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,1,0,1,1,1,1,1,1,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,1,0,1,0,1,1,1,1,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,1,1,0,1,1],\n                                [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]])\n        _TOPOLOGIA3 = np.array([[0,1,1,1,0,1,0,1,0,0,0,0,1,1,1],\n                                [0,0,1,1,0,1,0,1,0,0,0,0,1,1,1],\n                                [0,0,0,1,0,1,0,1,0,0,0,0,1,1,1],\n                                [1,1,1,0,0,1,0,1,0,0,0,0,1,1,1],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [1,1,1,1,0,0,0,1,0,0,0,0,1,1,1],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [1,1,1,1,0,1,0,0,0,0,0,0,1,1,1],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]])\n        _TOPOLOGIA4 = np.array([[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [1,1,1,1,0,1,0,1,0,0,0,0,1,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [1,1,1,1,1,1,0,1,0,0,0,0,1,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [1,1,1,1,1,1,1,1,0,0,0,0,1,0,0],\n                                [1,1,1,1,1,1,1,1,1,0,0,0,1,0,0],\n                                [1,1,1,1,1,1,1,1,1,1,0,0,1,0,0],\n                                [1,1,1,1,1,1,1,1,1,1,1,0,1,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]])\n        _TOPOLOGIA5 = np.array([[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [1,1,1,1,0,1,0,1,0,0,0,0,1,1,1],\n                                [1,1,1,1,0,1,0,1,0,0,1,0,1,1,1],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],\n                                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,0]])\n        _TOPOLOGIA6 = np.array([[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                                [1,1,1,1,1,1,1,1,1,1,1,1,0,1,1],\n                                [1,1,1,1,1,1,1,1,1,1,1,1,1,0,1],\n                                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,0]])\n\n        self._TOPOLOGIA = [[_TOPOLOGIA1, _TOPOLOGIA4],\n                      [_TOPOLOGIA2, _TOPOLOGIA5],\n                      [_TOPOLOGIA3, _TOPOLOGIA6]]\n\n        # Se obtiene de base de datos\n        self._TRAYECTOS = [{1:'Ida',2:'Vuelta'},{3:'Ida',4:'Vuelta'},{5:'Ida',6:'Vuelta'}]\n\n\n        \n        _SECUENCIA1 = np.array([1, 2, 3, 5, 7, 9, 10, 11, 12])\n        _SECUENCIA4 = np.array([12, 11, 10, 9, 7, 5, 3, 2, 1])\n        _SECUENCIA2 = np.array([1, 2, 3, 4, 6, 8, 10, 11, 12])\n        _SECUENCIA5 = np.array([12, 11, 14, 15, 3, 2, 1])\n        _SECUENCIA3 = np.array([1, 2, 3, 4, 6, 8, 13])\n        _SECUENCIA6 = np.array([13, 14, 15, 3, 2, 1])\n\n        self._SECUENCIAS = [[_SECUENCIA1, _SECUENCIA4],\n                       [_SECUENCIA2, _SECUENCIA5],\n                       [_SECUENCIA3, _SECUENCIA6]\n        ]\n\n\n\n        if transbordosM is not None:\n            self._TRANSBORDOS = transbordosM\n        else:\n            self._TRANSBORDOS = self.transbordos()\n\n        # self.TRANSBORDO = None # Variable para hacer dp cuando se calculan los self.transbordos().\n\n        self.EstacionesBaseDatosDict = None\n\n        self.FinTrayectoArray = finTrayecto\n\n        # self.EsRutaFantasma = [[False, False],\n        #                   [False, False],\n        #                   [False, True]\n        #                  ]\n\n        self.EsRutaFantasma = self.esRutaFantasmaFun()\n        \n        self._PROPORCIONES = np.array([[0,0.1,0.15,0.4,0.4,0.7,0.4,0.7,0.4,0.7,0.4,0.4,0.7,0.7,0.7],\n                                  [0.1,0,0.1,0.1,0.2,0.4,0.4,0.7,0.4,0.7,0.4,0.4,0.7,0.7,0.7],\n                                  [0.1,0.1,0,0.1,0.1,0.4,0.3,0.4,0.4,0.7,0.4,0.4,0.7,0.7,0.7],\n                                  [0.2,0.1,0.1,0,0.2,0.1,0.2,0.2,0.2,0.5,0.4,0.4,0.7,0.7,0.7],\n                                  [0.2,0.2,0.2,0.7,0,0.5,0.1,0.7,0.1,0.2,0.4,0.4,0.5,0.5,0.5],\n                                  [0.2,0.2,0.1,0.1,0.3,0,0.3,0.1,0.3,0.2,0.3,0.3,0.4,0.5,0.5],\n                                  [0.2,0.2,0.2,0.7,0.1,0.7,0,0.7,0.4,0.7,0.5,0.5,0.7,0.7,0.7],\n                                  [0.2,0.2,0.2,0.1,0.3,0.2,0.7,0,0.4,0.1,0.4,0.4,0.1,0.4,0.4],\n                                  [0.2,0.2,0.2,0.2,0.2,0.7,0.1,0.7,0,0.1,0.2,0.3,0.6,0.6,0.6],\n                                  [0.2,0.2,0.2,0.7,0.2,0.7,0.2,0.5,0.1,0,0.1,0.2,0.5,0.6,0.6],\n                                  [0.2,0.2,0.2,0.7,0.3,0.7,0.4,0.5,0.2,0.1,0,0.1,0.8,0.8,0.8],\n                                  [0.2,0.2,0.3,0.7,0.4,0.7,0.5,0.5,0.3,0.2,0.1,0,0.8,0.8,0.8],\n                                  [0.2,0.2,0.2,0.3,0.4,0.4,0.4,0.5,0.5,0.4,0.4,0.3,0,0.1,0.2],\n                                  [0.2,0.2,0.2,0.2,0.4,0.4,0.4,0.5,0.5,0.4,0.4,0.6,0.2,0,0.1],\n                                  [0.2,0.2,0.2,0.2,0.4,0.4,0.4,0.5,0.5,0.4,0.4,0.6,0.6,0.1,0]])\n\n        # print self._PROPORCIONES.sum(axis=0)\n        # Valores posibles de frecuencias, que van desde un periodo\n        # de 3 minutos a 15.5, con intervalos de 0.5 minutos\n        # Obteniendo un vector de posibles frecuencias con 25 valores\n        self.ValoresFrecuencias = 1/np.arange(3,16,0.5)\n\n        self.COSTOS = [5000,5000,5000] # Costos de cada Ruta\n\n    def cambiarVariablesOptimizacion(self, demanda = None, factorPasajero = None, factorOperador = None, \n                                     capacidadBuses = None, tiempoAbordar = None, tiempoEspera2Bus = None):\n        '''\n            Cambia las variables dependientes de la optimizacion, solo cambia las que son pasadas\n\n            Parametros\n            ----------\n                - demanda = int\n                - factorPasajero: int\n                - factorOperador: int\n                - capacidadBuses: int\n                - tiempoAbordar: int\n                - tiempoEspera2Bus: int\n            Return\n            ------\n                None\n        '''\n        if demanda:\n            self.NUMERODEMANDA = demanda\n        if factorPasajero:\n            self.FACTORPASAJERO = factorPasajero\n        if factorOperador:\n            self.FACTOROPERADEOR = factorOperador\n        if capacidadBuses:\n            self.CAPACIDADBUSES = capacidadBuses\n        if tiempoAbordar:\n            self.TIEMPOABORDAR = tiempoAbordar\n        if tiempoEspera2Bus:\n            self.TIEMPOESPERA2BUS = tiempoEspera2Bus\n\n    def cambiarVariablesJSON(self, horaInicio = None, horaFin = None):\n        '''\n            Cambia las variables dependientes de generar las tablas horarias en el archivo JSON,\n            solo cambia las que son pasadas\n\n            Parametros\n            ----------\n                - horaInicio = int\n                - horaFin = int\n            Return\n            ------\n                None\n        '''\n        if horaInicio:\n            self.HORAINICIO = horaInicio\n        if horaFin:\n            self.HORAFIN = horaFin\n       \n\n    def obtenerDatosBase(self, db_host = 'admin.megaruta.co', usuario ='rutamega_eqopt', clave = 'eedd8ae977b7f997ce92aa1b0', base_de_datos ='rutamega_principal'):\n        '''\n            Obtiene las variables principales para realizar las tablas horarias como son:\n                - Matrices de Transbordos: matricesTransbordo\n                - Matriz de Proporciones: matProporcion\n                - Diccionario de Estaciones: estacionDictInv {estacionOrden: idEstacionDB,...}\n                    Ej: {1: 38L, 2: 39L, 3: 36L, 4: 35L, 5: 34L, 6: 33L, 7: 10L, 8: 9L, 9: 8L...}\n                }\n                - Matrices Secuencias: matrizSecuencia. Esta siempre va ir ordenada en cada ruta \n                                       primero el trayecto ida y luego el de vuelta.\n                - Lista de Diccionario de Trayectos: trayectosList\n                    Ej: [{1: 'Ida', 2: 'Vuelta'}, {3: 'Ida', 4: 'Vuelta'}, {5: 'Vuelta', 6: 'Ida'}] \n                - Es Ruta Fantasma: EsRutaFantasma\n                - Estaciones de Fin de Trayectos: self.FinTrayectoArray\n                - Numero de Estaciones: numEstaciones\n                - Numero de Rutas: numRutas\n            Opcionales\n                - Matrices de Tiempos: matricesTiempo\n\n            Parametros\n            ----------\n                - db_host = Host de la Base de Datos\n                - usuario = Usuario de la Base de Datos\n                - clave   = Clave de la Base de Datos\n                - base_de_datos = Nombre de la Base de Datos\n\n            Return\n            ------\n                Vacio. Solo cambia matrices del programa.\n        '''\n\n        dbr = MySQLdb.connect(host=db_host, user=usuario, passwd=clave,db=base_de_datos)\n        cursor=dbr.cursor() # real\n        query_quotes =  \"SET sql_mode='ANSI_QUOTES'\" # para que acepte tablas con \"caracteres especiales\"\n        cursor.execute(query_quotes)\n        sql = '''SELECT * FROM \"estacion-matrices\"'''\n        sqlRutas = '''SELECT distinct idruta FROM \"estacion-matrices\";''' #Se puede sacar de IdTrayectos\n        sqlEstaciones = ''' SELECT distinct estaciones  From(SELECT distinct idestacionorigen as estaciones\n                            FROM \"estacion-matrices\"\n                            union all SELECT distinct idestaciondestino FROM \"estacion-matrices\") estaciones'''\n        sqlIdTrayectos = '''SELECT f.idtrayecto, b.idruta, f.sentidotrayecto FROM (SELECT idruta FROM \"estacion-matrices\" GROUP BY idruta)b\n                            LEFT JOIN trayecto f ON b.idruta = f.idruta;'''\n        # sqlSecuencias = '''SELECT te.idtrayecto, te.idestacion, te.ordentrayectoestacion FROM \"trayecto-estacion\" te, (SELECT f.idtrayecto idT FROM (SELECT idruta FROM \"estacion-matrices\" GROUP BY idruta)b LEFT JOIN trayecto f ON b.idruta = f.idruta)e WHERE e.idT = te.idtrayecto'''\n        sqlSecuencias = ''' SELECT te.idtrayecto, te.idestacion, te.ordentrayectoestacion\n                            FROM \"trayecto-estacion\" te,\n                            (SELECT distinct estaciones\n                            From(SELECT distinct idestacionorigen as estaciones FROM \"estacion-matrices\"\n                            union all SELECT distinct idestaciondestino FROM \"estacion-matrices\") estaciones) em\n                            WHERE em.estaciones = te.idestacion and te.estadotrayectoestacion = 'Activo'\n                            ORDER BY te.idtrayecto, te.ordentrayectoestacion;\n                        '''\n        sqlFinTrayecto = '''SELECT idestacion, fintrayecto FROM estacion where fintrayecto = 1; '''\n        try:\n            cursor.execute(sql)\n            # Obtenemos todos los registros en una lista de listas\n            resultados = cursor.fetchall()\n            cursor.execute(sqlRutas)\n            rutas = cursor.fetchall()\n            cursor.execute(sqlEstaciones)\n            estaciones = cursor.fetchall()\n            cursor.execute(sqlIdTrayectos)\n            idTrayectos = cursor.fetchall()\n            cursor.execute(sqlSecuencias)\n            secuencias = cursor.fetchall()\n            cursor.execute(sqlFinTrayecto)\n            # Contiene las estaciones finales de trayectos, sin incluir fantasmas\n            finTrayecto = cursor.fetchall() \n        except:\n           print \"Error: No se pudo obtener los datos\"\n\n        numEstaciones = len(estaciones)\n        numRutas = len(rutas)\n        matricesTiempo = []\n        matricesTransbordo = []\n        matDemanda = np.zeros((numEstaciones, numEstaciones))\n        matProporcion = np.zeros((numEstaciones, numEstaciones))\n        estacionesDict = {}\n\n        iR = 0\n\n        idTrayectosNP = np.array(idTrayectos)\n        trayectosDict = {}\n        for tray in idTrayectosNP:\n            trayectosDict[tray[0]] = tray[2]\n        for ruta in rutas:\n            instTransRuta = []\n            for trayecto in idTrayectosNP[idTrayectosNP[:,1] == str(ruta[0]),0]:\n                matTransbordo = np.zeros((numEstaciones, numEstaciones))\n                idTrayecto = resultados[iR][6] \n                for fila in range(numEstaciones):\n                    for columna in range(numEstaciones):\n                        if fila!=columna:\n                            # print numEstaciones*ruta + iR\n                            registro = resultados[iR]\n                            # matTiempo[fila,columna] = registro[4]\n                            matTransbordo[fila,columna] = registro[7]\n                            if registro[8]:\n                                matProporcion[fila,columna] = registro[8]\n                            # if registro[3]:\n                                # matDemanda[fila,columna] = registro[3]\n                            # if registro[8]:\n                                # matProporcion[fila,columna] = registro[8]\n                            estacionesDict[registro[2]]= columna+1\n                            iR +=1\n                matTransbordoT = np.zeros((numEstaciones, numEstaciones))\n                for i in estacionesDict:\n                    matTransbordoT[matTransbordo == i] = estacionesDict[i]\n\n                # Mientras arreglan self.transbordos en base de Datos\n                # if trayectosDict[str(idTrayecto)] == 'Ida':\n                #     instTransRuta.insert(0, matTransbordoT)\n                # else:\n                #     instTransRuta.append(matTransbordoT)\n                instTransRuta.append(matTransbordoT)\n\n            matricesTransbordo.append(instTransRuta)\n\n        secuenciasNP = np.array(secuencias)\n\n        matrizSecuencia = []\n        trayectosList = []\n        for i, ruta in enumerate(rutas):\n            trayectos = {}\n            secuenciaList2 = []\n            for trayecto in idTrayectosNP[idTrayectosNP[:,1].astype(int)  == ruta]:\n                # Se crea un diccionario solo con el id del trayecto y su valor\n                # ej: trayecto [1, 3, vuelta] :: [idtrayecto, idruta, sentido]\n                nuevaSecuencia = secuenciasNP[secuenciasNP[:,0]== int(trayecto[0])]\n                trayectos[int(trayecto[0])] = trayecto[2]\n\n                secuenciaList = []\n                for i, elemento in enumerate(nuevaSecuencia):\n                    secuenciaList.append(estacionesDict[elemento[1]])\n\n                if trayecto[2] == 'Ida':\n                    secuenciaList2.insert(0, np.array(secuenciaList))\n                else:\n                    secuenciaList2.append(np.array(secuenciaList))\n\n            matrizSecuencia.append(secuenciaList2)\n            trayectosList.append(trayectos) # Se añaden los trayectos de la ruta\n\n        estacionDictInv= {}\n        for estacionBase, estacionMod in estacionesDict.iteritems():\n            estacionDictInv[estacionMod] = estacionBase\n\n        self.FinTrayectoArray = []\n        for estacion in finTrayecto:\n            self.FinTrayectoArray.append(estacionesDict[estacion[0]]-1)\n        # print self.FinTrayectoArray\n\n        self.EsRutaFantasma = []\n        for ruta in matrizSecuencia:\n            rutaF = [False]\n            secuencia = ruta[0]\n            if secuencia[-1] -1 in self.FinTrayectoArray:\n                rutaF.append(False)\n            else:\n                rutaF.append(True)\n            self.EsRutaFantasma.append(rutaF)\n        # print self.EsRutaFantasma\n\n        # print estacionDictInv\n\n        self.EstacionesBaseDatosDict = estacionDictInv\n        # print json.dumps(estacionesDict, sort_keys = True) \n        self.NUMEROESTACIONES = numEstaciones\n        self.NUMERORUTAS      = numRutas\n        self._TRANSBORDOS     = matricesTransbordo\n        self._SECUENCIAS      = matrizSecuencia\n        self._TRAYECTOS       = trayectosList\n        self._PROPORCIONES    = matProporcion\n\n    # print self.EstacionesBaseDatosDict\n    def esRutaFantasmaFun(self):\n        self.EsRutaFantasma = []\n        for ruta in self._SECUENCIAS:\n            rutaF = [False]\n            secuencia = ruta[0]\n            if secuencia[-1] -1 in self.FinTrayectoArray:\n                rutaF.append(False)\n            else:\n                rutaF.append(True)\n            self.EsRutaFantasma.append(rutaF)\n        return self.EsRutaFantasma\n\n    def generarCSV(self):\n        for ruta in range(self.NUMERORUTAS):\n            np.savetxt(\"archivos/TiempoEntreEstaciones.csv\", self._TIEMPO_ENTRE_ESTACIONES[ruta], delimiter=\",\", fmt = \"%10.5f\")\n            for trayecto in [0,1]:\n                if trayecto == 0:\n                    np.savetxt(\"archivos/Secuencia\"+str(ruta+1)+\"Ida.csv\", self._SECUENCIAS[ruta][trayecto], delimiter=\",\", fmt = \"%10.5f\")\n                    np.savetxt(\"archivos/Transbordos\"+str(ruta+1)+\"Ida.csv\", self._TRANSBORDOS[ruta][trayecto], delimiter=\",\", fmt = \"%10.5f\")\n                    np.savetxt(\"archivos/Topologia\"+str(ruta+1)+\"Ida.csv\", self._TOPOLOGIA[ruta][trayecto], delimiter=\",\", fmt = \"%10.5f\")\n                else:\n                    np.savetxt(\"archivos/Secuencia\"+str(ruta+1)+\"Vuelta.csv\", self._SECUENCIAS[ruta][trayecto], delimiter=\",\", fmt = \"%10.5f\")\n                    np.savetxt(\"archivos/Transbordos\"+str(ruta+1)+\"Vuelta.csv\", self._TRANSBORDOS[ruta][trayecto], delimiter=\",\", fmt = \"%10.5f\")\n                    np.savetxt(\"archivos/Topologia\"+str(ruta+1)+\"Vuelta.csv\", self._TOPOLOGIA[ruta][trayecto], delimiter=\",\", fmt = \"%10.5f\")\n        np.savetxt(\"archivos/Proporciones.csv\", self._PROPORCIONES, delimiter=\",\", fmt = \"%10.5f\")\n\n    def tiempoTrayectosDirectos(self, trayectosValue):\n        '''\n            Devuelve la matriz de tiempo trayectos directos tiempoTrayectos[indiceTrayecto][indiceRuta][fila, columna]\n\n            Parametros\n            ----------\n            - trayectosValue: matriz que contiene la secuencia del trayecto de las rutas. \n                Ej: [...,[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [16, 17, 18, 19, 20, 21, 22, 23, 24, 6, 5, 4, 3, 2, 1]]] \n                Se muestra solo las secuencias de la ruta 3 trayecto vuelta del modelo de 40 estaciones\n\n            Return\n            ------\n            - tiempoTrayectos: matriz donde se encuentran los tiempos directos de cada trayecto de cada ruta\n                [indiceTrayecto][indiceRuta][np.array(NUMEROESTACIONES,NUMEROESTACIONES)]\n\n        '''\n        tiemposTrayectos = []\n        for indexT, trayectoValue in enumerate(trayectosValue):\n            trayectoVect = []\n            for indexR, ruta in enumerate(trayectoValue):\n                tiempo = np.zeros((self.NUMEROESTACIONES, self.NUMEROESTACIONES))\n                for i, index in enumerate(ruta[:-1]):\n                    siguiente = ruta[i+1]\n                    tiempo[index, siguiente] = self._TiempoDirectoTrayectos[indexT][indexR][i]\n                    # tiemposTrayectos[indexT][indexR][index, siguiente] = self._TiempoDirectoTrayectos[indexT][indexR][i]\n                trayectoVect.append(tiempo)\n            tiemposTrayectos.append(trayectoVect)\n                    \n\n        for indexT, trayectoValue in enumerate(trayectosValue):\n            for indexR, ruta in enumerate(trayectoValue):\n                for k in range(1,len(ruta[:-1])):\n                    for i, sec in enumerate(ruta[:-1]):\n                        if i+k <= len(ruta)-2:\n                            siguiente = ruta[i+k]\n                            if siguiente != ruta[-1]:\n                                j = ruta[i+k+1]\n                                tiemposTrayectos[indexT][indexR][sec,j] = tiemposTrayectos[indexT][indexR][sec,siguiente]\\\n                                 + tiemposTrayectos[indexT][indexR][siguiente, j]\n        return tiemposTrayectos\n\n    def tiempoTrayectosTransbordo(self, trayectosValue):\n        '''\n            Devuelve la matriz de tiempo trayectos contando self.transbordos tiempoTrayectos[indiceTrayecto][indiceRuta][fila, columna]\n\n            Parametros\n            ----------\n            - trayectosValue: matriz que contiene la secuencia del trayecto de las rutas. \n                Ej: [...,[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], [16, 17, 18, 19, 20, 21, 22, 23, 24, 6, 5, 4, 3, 2, 1]]] \n                Se muestra solo las secuencias de la ruta 3 trayecto vuelta del modelo de 40 estaciones\n\n            Return\n            ------\n            - tiempoTrayectos: matriz donde se encuentran los tiempos de cada trayecto de cada ruta con los self.transbordos\n                [indiceTrayecto][indiceRuta][np.array(NUMEROESTACIONES,NUMEROESTACIONES)]\n\n        '''\n        tiemposTrayectos = self.tiempoTrayectosDirectos(trayectosValue)\n        for indR, ruta in enumerate(self._TRANSBORDOS):\n            if not(trayectosValue[0][indR][-1] in self.FinTrayectoArray):\n                fantasma = True\n            else:\n                fantasma = False\n            for indT, matriz in enumerate(ruta):\n                indicesNonZero = np.nonzero(matriz)\n                for i in range(len(indicesNonZero[0])):\n                    estacionTransbordo = matriz[indicesNonZero[0][i],indicesNonZero[1][i]] -1\n                    if fantasma:\n                        if estacionTransbordo in trayectosValue[indT][indR][trayectosValue[indT][indR].index(indicesNonZero[0][i]):]:\n                            tiempoInicioTransbordo = tiemposTrayectos[indT][indR][indicesNonZero[0][i], estacionTransbordo]\n                        else:\n                            # Si no se encuentra la Estacion de Transbordo en la secuencia, se sumará el tiempo de ir hasta la\n                            # estación final y luego la del trayecto de vuelta hasta la de transbordo\n                            tiempoInicioTransbordo = tiemposTrayectos[0][indR][indicesNonZero[0][i], trayectosValue[0][indR][-1]] \\\n                            + tiemposTrayectos[1][indR][trayectosValue[1][indR][0], estacionTransbordo]\n\n                    else:\n                        tiempoInicioTransbordo = tiemposTrayectos[indT][indR][indicesNonZero[0][i], estacionTransbordo]\n                    tiempo = None\n                    for indT2, rutaTrayecto in enumerate(trayectosValue):\n                        for indR2, trayecto in enumerate(rutaTrayecto):\n                            if estacionTransbordo in trayecto:\n                                if indicesNonZero[1][i] in trayecto[np.where(trayecto==estacionTransbordo)[0]:]: \n                                    if fantasma:\n                                        sumaTiempos = (tiempoInicioTransbordo + \n                                        tiemposTrayectos[indT][indR][estacionTransbordo, indicesNonZero[1][i]]) \n                                        tiemposTrayectos[indT][indR][indicesNonZero[0][i], indicesNonZero[1][i]] =(\n                                            sumaTiempos)\n                                    else:\n                                        sumaTiempos = (tiempoInicioTransbordo + \n                                        tiemposTrayectos[indT2][indR2][estacionTransbordo, indicesNonZero[1][i]]) \n                                        if tiempo == None: # Si es el primero en encontrarlo\n                                            tiemposTrayectos[indT][indR][indicesNonZero[0][i], indicesNonZero[1][i]] =(\n                                            sumaTiempos)\n                                            tiempo = tiemposTrayectos[indT][indR][indicesNonZero[0][i], indicesNonZero[1][i]]\n                                        elif tiempo > sumaTiempos:\n                                            tiemposTrayectos[indT][indR][indicesNonZero[0][i], indicesNonZero[1][i]] =(\n                                            sumaTiempos)\n                                            tiempo = tiemposTrayectos[indT][indR][indicesNonZero[0][i], indicesNonZero[1][i]]\n                                elif fantasma:\n                                    if indicesNonZero[1][i] in trayectosValue[1][indR2]:\n                                        sumaTiempos = (tiempoInicioTransbordo + \n                                        tiemposTrayectos[indT2][indR2][estacionTransbordo, trayectosValue[indT2][indR2][-1]] +\n                                        tiemposTrayectos[1][indR2][trayectosValue[1][indR][0], indicesNonZero[1][i]]) \n                                        if tiempo == None: # Si es el primero en encontrarlo\n                                            tiemposTrayectos[indT][indR][indicesNonZero[0][i], indicesNonZero[1][i]] =(\n                                            sumaTiempos)\n                                            tiempo = tiemposTrayectos[indT][indR][indicesNonZero[0][i], indicesNonZero[1][i]]\n                                        elif tiempo > sumaTiempos:\n                                            tiemposTrayectos[indT][indR][indicesNonZero[0][i], indicesNonZero[1][i]] =(\n                                            sumaTiempos)\n                                            tiempo = tiemposTrayectos[indT][indR][indicesNonZero[0][i], indicesNonZero[1][i]]\n        return tiemposTrayectos\n\n    def tiempoTrayectosRutas(self, tiemposTrayectos):\n        '''\n            Devuelve la matriz de tiempo trayectos contando self.transbordos tiempoTrayectos[indiceTrayecto][indiceRuta][fila, columna]\n\n            Parametros\n            ----------\n                - tiempoTrayectos:    \n\n            Return\n            ------\n\n        '''\n        tiempoRutas = []\n        for indR in range(self.NUMERORUTAS):\n            tiempoRutas.append(tiemposTrayectos[0][indR] + tiemposTrayectos[1][indR])\n        return tiempoRutas\n\n    def obtenerTopologias(self, tiemposTrayectos):\n        '''\n            Crea las matrices de Topologias a traves de las matrices de tiempo\n\n            Parametros\n            ----------\n                - tiempoTrayectos: \n        '''\n        matricesTopologia = []\n        for indexT, tiempo in enumerate(tiemposTrayectos):\n            trayecto = []\n            for i, ruta in enumerate(tiempo):\n                topologia = np.zeros((self.NUMEROESTACIONES, self.NUMEROESTACIONES))\n                topologia[ruta>0] = 1\n                # if indexT == 0:\n                    # np.savetxt(\"tiemposRuta\"+str(i+1)+\"IdaV2.csv\", ruta, delimiter=\",\", fmt = \"%10.5f\")\n                    # np.savetxt(\"topologiaRuta\"+str(i+1)+\"IdaV2.csv\", topologia, delimiter=\",\", fmt = \"%d\")\n                # else:\n                    # np.savetxt(\"tiemposRuta\"+str(i+1)+\"VueltaV2.csv\", ruta, delimiter=\",\", fmt = \"%10.5f\")\n                    # np.savetxt(\"topologiaRuta\"+str(i+1)+\"VueltaV2.csv\", topologia, delimiter=\",\", fmt = \"%d\")\n                trayecto.append(topologia)\n            matricesTopologia.append(trayecto)\n\n        matricesTopologia = zip(*matricesTopologia)\n        return matricesTopologia\n\n    def numeroEstaciones(self):\n        \"Devuelve la cantidad de estaciones totales, para generar rango de matrices\"\n        for ruta in self._SECUENCIAS:\n            for secuencia in ruta:\n                maximo = secuencia.max()\n                if maximo > self.NUMEROESTACIONES:\n                    self.NUMEROESTACIONES = maximo\n        return self.NUMEROESTACIONES\n    # self.numeroEstaciones()\n\n    def tiempoEntreEstaciones(self):\n        \"Crea las matrices de Tiempo Entre Estaciones, solo se toman en cuenta las directas\"\n        _tiempoEntreEstaciones = []\n        for ruta in self._SECUENCIAS:\n            _tiempoEntreEstacionesT = np.zeros(shape=(self.NUMEROESTACIONES,self.NUMEROESTACIONES))\n            # print ruta\n            for secuencia in ruta:\n                # print secuencia\n                secuenciaN = secuencia-1\n                for i, act in enumerate(secuenciaN[:-1]):\n                    # print i, act, secuenciaN[:-1]\n                    siguiente = secuenciaN[i+1]\n                    _tiempoEntreEstacionesT[act,siguiente] = 2 # Distancia entre estaciones\n                for k in range(1,len(secuenciaN[:-1])):\n                    for i, sec in enumerate(secuenciaN[:-1]):\n                        if i+k <= len(secuenciaN)-2:\n                            siguiente = secuenciaN[i+k]\n                            if siguiente != secuenciaN[-1]:\n                                j = secuenciaN[i+k+1]\n                                # for j in secuenciaN[i+2:-1]:\n                                    # print _tiempoEntreEstacionesT[sec,j], _tiempoEntreEstacionesT[sec,siguiente], _tiempoEntreEstacionesT[siguiente, j]\n                                    # print sec, j, \" : \", sec, siguiente, \" , \", siguiente, j, secuenciaN[i+2:-1]\n                                _tiempoEntreEstacionesT[sec,j] = _tiempoEntreEstacionesT[sec,siguiente] + _tiempoEntreEstacionesT[siguiente, j]\n\n\n            _tiempoEntreEstaciones.append(_tiempoEntreEstacionesT)\n        return np.array(_tiempoEntreEstaciones)\n\n    # print self.tiempoEntreEstaciones()\n\n    def mejoresSecuencias(self):\n        '''\n        Devuelve una matriz con las mejores secuencias para ir de una estación a otra\n        (algoritmo de fuerza bruta, se puede optimizar con programacion dinámica)\n        '''\n        _mejoresSecuencias = []\n        _tiempoEntreEstaciones = self.tiempoEntreEstaciones()\n        for ind in range(self.NUMEROESTACIONES):\n            fila = []\n            for indj in range(self.NUMEROESTACIONES):\n                minimo = 200\n                _mejorSecuencia = []\n                for ruta in _tiempoEntreEstaciones:\n                    tiempo = ruta[ind,indj]\n                    if tiempo != 0 and tiempo <= minimo:\n                        minimo = tiempo\n                        _mejorSecuencia = [ind+1, indj+1]\n                if indj == ind:\n                    _mejorSecuencia = [ind+1, indj+1]\n                fila.append(_mejorSecuencia)\n            _mejoresSecuencias.append(fila)\n        for i, fila in enumerate(_mejoresSecuencias):\n            for j, secuencia in enumerate(fila):\n                if len(secuencia) == 0:\n                    minimo = 200\n                    for indRuta1, ruta1 in enumerate(self._SECUENCIAS):\n                        # rutaN = []\n                        # trayectoN = []\n                        for trayecto in ruta1:\n                            secuenciaN = trayecto-1\n                            if j in secuenciaN:\n                                r = np.array(range(len(secuenciaN==j)))\n                                index = int(r[secuenciaN==j])\n                                for estacionI in secuenciaN[:index]: # Estación intermedia\n                                    minimoN = _tiempoEntreEstaciones[indRuta1][estacionI, j]\n                                    for indRuta2, ruta2 in enumerate(self._SECUENCIAS):\n                                        for trayecto2 in ruta2:\n                                            secuenciaN2 = trayecto2-1\n                                            if estacionI in secuenciaN2:\n                                                r1 = np.array(range(len(secuenciaN2==estacionI)))\n                                                index1 = int(r1[secuenciaN2==estacionI])\n                                                if i in secuenciaN2[:index1]:\n                                                    minimoN += _tiempoEntreEstaciones[indRuta2][i, estacionI]\n                                                    if minimoN < minimo:\n                                                        minimo = minimoN\n                                                        _mejoresSecuencias[i][j] = [i+1, estacionI+1, j+1]\n        _mejoresSecuencias[14][13] = [15,3,13,14]\n        _mejoresSecuencias[5][3]   = [6,3,4]\n        _mejoresSecuencias[7][3]   = [8,3,4]\n        _mejoresSecuencias[7][5]   = [8,3,6]\n\n        # return np.array(_mejoresSecuencias)\n        return _mejoresSecuencias\n    # print self.mejoresSecuencias()\n\n    def transbordos(self):\n        '''\n        Devuelve las matrices de self.transbordos de acuerdo a la matriz de mejores secuencias\n        Se implementa DP, con la variable de self.TRANSBORDO\n        '''\n        # global self.TRANSBORDO\n        # if self.TRANSBORDO == None: # Si no se han asignado self.transbordos\n            # Se toman las mejores secuencias (utilizando rutas más cortas)\n        _mejoresSecuenciasT = self.mejoresSecuencias()\n        _mejoresSecuenciasN = []\n        for ir ,ruta in enumerate(self._SECUENCIAS):\n            r = []\n            for it, trayecto in enumerate(ruta):\n                tr = np.zeros(shape=(self.NUMEROESTACIONES,self.NUMEROESTACIONES))\n                if ir == 2 and it == 1: # Si es estación fantasma\n                    # Se concatenan las dos secuencias, la de trayecto ida y la de vuelta.\n                    sec = np.concatenate((ruta[0]-1,ruta[1]-1))\n                else: # Si es cualquier estación normal, se asigna el trayecto actual\n                    sec = trayecto-1\n                # print sec\n                for i, act in enumerate(sec):\n                    for j in range(self.NUMEROESTACIONES):\n                        if len(_mejoresSecuenciasT[act][j])>=3 and _mejoresSecuenciasT[act][j][1] != 13:\n                            estaTrans = _mejoresSecuenciasT[act][j][1] # Estación de transbordo\n                            # Si la estación de transbordo está más adelante en la matriz trayecto\n                            # Se le asigna esta estación de transbordo.\n                            if np.in1d(estaTrans, sec[i:]+1):\n                                tr[act,j] = estaTrans\n                r.append(tr)\n            _mejoresSecuenciasN.append(np.array(r))\n\n            # self.TRANSBORDO = np.array(_mejoresSecuenciasN)\n\n        # return self.TRANSBORDO\n        return np.array(_mejoresSecuenciasN)\n\n\n    def tiempoEsperaMaximo(self, t):\n        \"Devuelve matriz de Tiempo de Espera Maximo para el trayecto 't'\"\n        suma = np.zeros(shape=(self.NUMEROESTACIONES, self.NUMEROESTACIONES))\n        # if model!=None:\n        #     for r in range(len(model)):\n\n        #         for i in range(suma.shape[0]):\n        #             for j in range(suma.shape[1]):\n        #                 suma[i,j] += self._TOPOLOGIA[r][t][i,j]*model[r]\n        # else:\n        for r in range(len(self.FrecuenciasOptimas)):\n            if r == 0:\n                suma = self._TOPOLOGIA[r][t]*self.FrecuenciasOptimas[r]\n            else:\n                suma += self._TOPOLOGIA[r][t]*self.FrecuenciasOptimas[r]\n        with np.errstate(divide='ignore'):\n            result = 1/suma\n        result[np.isinf(result)] = 0\n\n        return np.array(result)\n        # return np.around(result, decimals = 2)\n\n    def topologiaTot(self):\n        '''\n        Topologia sin trayectos\n        '''\n        _MatrizTopologia = []\n        for x in self._TOPOLOGIA:\n            _MatrizTopologia.append(x[0] + x[1])\n        return _MatrizTopologia\n\n    def tiempoEsperaMaximoTot(self):\n        \"Devuelve matriz de Tiemo de Espera Máximo total para los dos trayectos\"\n        suma = np.zeros(shape=(self.NUMEROESTACIONES, self.NUMEROESTACIONES))\n        topologiaTotV = self.topologiaTot()\n        # if model!=None:\n        #     for r in range(len(model)):#self.FrecuenciasOptimas)):\n        #         # suma += topologiaTotV[r]*value(model[r])\n        #         for i in range(suma.shape[0]):\n        #             for j in range(suma.shape[1]):\n        #                 suma[i,j] += topologiaTotV[r][i,j]*model[r]\n        # else:\n        for r in range(len(self.FrecuenciasOptimas)):\n            if r == 0:\n                suma = topologiaTotV[r]*self.FrecuenciasOptimas[r]#value(self.FrecuenciasOptimas[r]))\n            else:\n                suma += topologiaTotV[r]*self.FrecuenciasOptimas[r]#value(self.FrecuenciasOptimas[r]))\n\n        with np.errstate(divide='ignore'):\n            result = 1/suma\n\n        # for i in range(result.shape[0]):\n        #     for j in range(result.shape[1]):\n        #         topologia1 = 0\n        #         topologia2 = 0\n        #         for r in range(len(self.FrecuenciasOptimas)):\n        #             secuencia = _MEJOR_SECUENCIA[r][i][j]\n        #             if len(secuencia)== 3:\n        #                 topologia1 += topologiaTotV[r][secuencia[0]-1,secuencia[1]-1]*self.FrecuenciasOptimas[r]\n        #                 topologia2 += topologiaTotV[r][secuencia[1]-1,secuencia[2]-1]*self.FrecuenciasOptimas[r]\n        #                 if r == 2:\n        #                     result[i,j] = (1/topologia1) + (1/topologia2)\n\n        result[np.isinf(result)] = 0\n        return result\n        #return np.around(result, decimals = 2)\n\n\n\n    def demandaMediaConstante(self, x):\n        _Demanda = np.zeros(shape= (self.NUMEROESTACIONES, self.NUMEROESTACIONES))\n        _Demanda.fill(x)\n        np.fill_diagonal(_Demanda,[0]*self.NUMEROESTACIONES)\n        return _Demanda\n\n    # print self.demandaMediaConstante(3)\n\n    def tiempoEsperaPromedio(self, t):\n        \"Devuelve matriz de Tiempo de Espera Promedio para cada trayecto 't'\"\n        return np.array(self.tiempoEsperaMaximo(t)/2)\n\n    # print np.around(self.tiempoEsperaPromedio(1), decimals = 2)\n\n    def tiempoEsperaPromedioTot(self):\n        \"Devuelve matriz de Tiempo de Espera Promedio total\"\n        return np.array(self.tiempoEsperaMaximoTot()/2)\n\n\n\n    def matrizDemandaMedia(self):\n        \"Devuelve matriz de Demanda Media, \"\n        # arrayDemandaMedia = np.array(_DEMANDA_MEDIA)\n        arrayDemandaMedia = self.demandaMediaConstante(self.NUMERODEMANDA)\n        a = 0.4*self.tiempoEsperaPromedioTot()*arrayDemandaMedia\n        return np.array((a + arrayDemandaMedia) * (self._PROPORCIONES))\n\n    # print np.around(self.matrizDemandaMedia(), decimals = 2)\n\n\n    # matrizProbabilidadEleccionDP = np.empty((2,3,25))\n    # matrizProbabilidadEleccionDP.fill(-1)\n    # print matrizProbabilidadEleccionDP[0,0]\n\n    def probabilidadEleccion(self, r, t):\n        \"Devuelve matriz de probabilidad de Elección para el trayecto 't' de la ruta 'r'\"\n        topologia = self._TOPOLOGIA[r][t]\n        # if model!=None:\n        #     frecuencia = model[r]#self.FrecuenciasOptimas[r]\n        # else:\n        frecuencia = self.FrecuenciasOptimas[r]\n        # Se convierte del tipo array para que la multiplicación no sea matricial\n        tiempoEsperaM = np.array(self.tiempoEsperaMaximo(t))\n        return np.array(topologia*tiempoEsperaM*frecuencia)\n\n    # print np.around(self.probabilidadEleccion(0,0), decimals = 2)\n\n    def distribucionDemanda(self, r, t):\n        \"Devuelve matriz de Distribucion de Demanda para el trayecto 't' de la ruta 'r'\"\n        return self.matrizDemandaMedia()*self.probabilidadEleccion(r, t)\n\n    # print np.around(self.distribucionDemanda(0,0), decimals= 2)\n\n    def pasajerosEstacion(self, r, t):\n        \"Devuelve arreglo de pasajeros en estación para el trayecto 't' de la ruta 'r'\"\n        return self.distribucionDemanda(r, t).sum(axis= 1)\n\n    def pasajerosEstacionValida(self, r, t):\n        '''\n        Devuelve una arreglo binario, en donde haya más de un pasajero en la estación se marca 1\n        para el trayecto 't' de la ruta 'r'\n        '''\n        x = self.pasajerosEstacion(r, t)\n        x[x>0] = 1\n        # for i in range(x.shape[0]):\n        #     if value(x[i]) >= 0.000001:\n        #         x[i] = 1\n        return x\n\n    def pasajerosPuedenAbordar(self, r, t):\n        '''\n            Crea matriz de los pasajeros que pueden abordar, un vector de los que pueden subir\n            y  un vector de capacidades para el trayecto 't' de la ruta 'r'.\n        '''\n        # Toma la secuencia utilizara por la ruta r en el trayecto t\n        secuencia = self._SECUENCIAS[r][t]-1\n        pasajeros = self.pasajerosEstacion(r, t)\n        # Se crea un arreglo de zeros con tamaño igual al numero de estaciones\n        capacidad = np.zeros(shape=(self.NUMEROESTACIONES))\n        # Se crea un arreglo de zeros con tamaño igual al numero de estaciones\n        puedenSubir = np.zeros(shape=(self.NUMEROESTACIONES))\n         # Se crea una matriz cuadrada de zeros con tamaño igual al numero de estaciones\n        _pasajerosPuedenAbordar = np.zeros(shape=(self.NUMEROESTACIONES,self.NUMEROESTACIONES))\n        mTransbordo = self._TRANSBORDOS[r][t]\n        i = secuencia[0] # Se toma la estación inicial\n        capacidad[i] = self.CAPACIDADBUSES - pasajeros[i] # Se inicializa el arreglo de capacidades\n        puedenSubir[i] = self.CAPACIDADBUSES # Se inicializa el arreglo de puedenSubir\n        if puedenSubir[i] >= pasajeros[i]:\n            _pasajerosPuedenAbordar[i,:] = self.distribucionDemanda(r,t)[i,:]\n        else:\n            _pasajerosPuedenAbordar[i,:] = self.distribucionDemanda(r,t)[i,:] / (pasajeros[i]*puedenSubir[i])\n        if t == 0: # Si el trayecto es de ida\n            for iS, i in enumerate(secuencia[1:]):\n\n                valido = self.pasajerosEstacionValida(r, t)[i]\n                anterior = secuencia[iS]\n\n                pasajerosSuma = _pasajerosPuedenAbordar[:i,i].sum()\n                pasajerosTransbordo = 0\n                if np.in1d(i+1, mTransbordo):\n                    mTransbordoB = mTransbordo == i+1\n                    pasajerosTransbordo = _pasajerosPuedenAbordar[mTransbordoB].sum()\n\n                if capacidad[anterior] > pasajeros[i]:\n                    capacidad[i] = capacidad[anterior] - pasajeros[i] + pasajerosSuma + pasajerosTransbordo\n                else:\n                    capacidad[i] = 0\n\n                if capacidad[anterior] > 0:\n                    puedenSubir[i] = (capacidad[anterior] + pasajerosSuma + pasajerosTransbordo)*valido\n                else:\n                    puedenSubir[i] = (pasajerosSuma + pasajerosTransbordo)*valido\n                # if round(puedenSubir[i]) >= pasajeros[i]:\n                if puedenSubir[i] >= pasajeros[i]:\n                    _pasajerosPuedenAbordar[i,:] = self.distribucionDemanda(r, t)[i,:]\n                else:\n                    _pasajerosPuedenAbordar[i,:] = (self.distribucionDemanda(r, t)[i,:]/pasajeros[i])*puedenSubir[i]\n                # print _MEJOR_SECUENCIA[r][i-1][i]\n        else: # Si el trayecto es de Vuelta\n            # if r == 2 and t == 1: # Si es un final fantasma\n            if self.EsRutaFantasma[r][t]:\n                puedAbordI               = self.pasajerosPuedenAbordar(r, 0) \n                # Pasajeros que pueden abordar ida\n                pasajerosPuedenAbordarI  = puedAbordI[0]\n                # Capacidad que pueden abordar ida\n                capacidadI               = puedAbordI[2]#[self._SECUENCIAS[r][0][-1]-1]\n                # puedenSubirI             = puedAbordI[1]#[:self._SECUENCIAS[r][0][-1]-1,secuencia[1]]\n                secuenciaI               = self._SECUENCIAS[r][0]-1 # Secuencia ida\n                anterior                 = secuenciaI[-1]\n                mTransbordoI          = self._TRANSBORDOS[r][0]# Transbordo ida\n\n                pasajerosSuma = 0\n                for x in secuenciaI:\n                        pasajerosSuma += pasajerosPuedenAbordarI[x,i]\n\n                if capacidad[anterior] > 0:\n                    puedenSubir[i] = capacidadI[anterior] + pasajerosSuma\n                else:\n                    puedenSubir[i] = pasajerosSuma\n\n                if capacidad[anterior] > pasajeros[i]:\n                    capacidad[i] = capacidad[anterior] - pasajeros[i] + pasajerosSuma\n                else:\n                    capacidad[i] = 0\n                # print puedenSubir[i]\n                if puedenSubir[i] >= pasajeros[i]:\n                    _pasajerosPuedenAbordar[i,:] = self.distribucionDemanda(r,t)[i,:]\n                else:\n                    _pasajerosPuedenAbordar[i,:] = (self.distribucionDemanda(r,t)[i,:]/pasajeros[i])*puedenSubir[i]\n\n                for iS, i in enumerate(secuencia[1:]): # iS -> Contador, i -> Estacion secuencia\n                    valido = self.pasajerosEstacionValida(r, t)[i]\n                    anterior = secuencia[iS]\n                    pasajerosSuma  = 0\n                    pasajerosSumaI = 0\n                    if np.in1d(i+1, secuenciaI):\n                        for x in secuenciaI[i:]:\n                            pasajerosSumaI += pasajerosPuedenAbordarI[x,i]\n                    else:\n                        for x in secuenciaI:\n                            pasajerosSumaI += pasajerosPuedenAbordarI[x,i]\n\n                    for x in secuencia[:iS+1]:\n                        pasajerosSuma += _pasajerosPuedenAbordar[x,i]\n\n                    pasajerosTransbordo = 0\n                    if np.in1d(i+1, mTransbordo) or np.in1d(i+1, mTransbordoI):\n                        mTransbordoB = mTransbordo == i+1\n                        mTransbordoBI = mTransbordoI > 0 # mTransbordo == i+1 Temporalmente > 0 por error de minimizacion en excel\n                        pasajerosTransbordo = _pasajerosPuedenAbordar[mTransbordoB].sum() + pasajerosPuedenAbordarI[mTransbordoBI].sum()\n\n                    if capacidad[anterior] > 0:\n                        puedenSubir[i] = (capacidadI[anterior] + pasajerosSuma + pasajerosSumaI + pasajerosTransbordo)*valido\n                    else:\n                        puedenSubir[i] = (pasajerosSuma +  pasajerosSumaI + pasajerosTransbordo)*valido\n\n                    if capacidad[anterior] > pasajeros[i]:\n                        capacidad[i] = capacidad[anterior] - pasajeros[i] + pasajerosSuma + pasajerosSumaI + pasajerosTransbordo\n\n                    if puedenSubir[i] >= pasajeros[i]:\n                        _pasajerosPuedenAbordar[i,:] = self.distribucionDemanda(r,t)[i,:]\n                    else:\n                        _pasajerosPuedenAbordar[i,:] = (self.distribucionDemanda(r,t)[i,:]/pasajeros[i])*puedenSubir[i]\n            else:\n                for iS, i in enumerate(secuencia[1:]):\n\n                    valido = self.pasajerosEstacionValida(r, t)[i]\n                    anterior = secuencia[iS]\n                    pasajerosSuma = 0#_pasajerosPuedenAbordar[i-len(_pasajerosPuedenAbordar):,i].sum()\n                    # pasajerosSuma = _pasajerosPuedenAbordar[i-len(_pasajerosPuedenAbordar):,i].sum()\n                    for x in secuencia[:iS+1]:\n                        pasajerosSuma += _pasajerosPuedenAbordar[x,i]\n\n                    pasajerosTransbordo = 0\n                    if np.in1d(i+1, mTransbordo):\n                        mTransbordoB = mTransbordo == i+1\n                        pasajerosTransbordo = _pasajerosPuedenAbordar[mTransbordoB].sum()\n\n                    if capacidad[anterior] > pasajeros[i]:\n                        capacidad[i] = capacidad[anterior] - pasajeros[i] + pasajerosSuma + pasajerosTransbordo\n                    else:\n                        capacidad[i] = 0\n\n                    if capacidad[anterior] > 0:\n                        puedenSubir[i] = (capacidad[anterior] + pasajerosSuma + pasajerosTransbordo)*valido\n                    else:\n                        puedenSubir[i] = (pasajerosSuma + pasajerosTransbordo)*valido\n                        # print i,anterior, puedenSubir[i], _pasajerosPuedenAbordar[i-len(_pasajerosPuedenAbordar):,i]\n                    if puedenSubir[i] >= pasajeros[i]:\n                        _pasajerosPuedenAbordar[i,:] = self.distribucionDemanda(r,t)[i,:]\n                    else:\n                        _pasajerosPuedenAbordar[i,:] = (self.distribucionDemanda(r,t)[i,:]/pasajeros[i])*puedenSubir[i]\n        # print np.around(puedenSubir, decimals= 0)\n        # print capacidad\n        # print np.rint(pasajeros)\n        return [_pasajerosPuedenAbordar, puedenSubir, capacidad]\n    # psPA = self.pasajerosPuedenAbordar(0,0)\n    # print np.around(psPA[0], decimals=2) , psPA[1], psPA[2]\n\n\n    def tiempoEsperaEstaciones(self, r, t):\n        \"Devuelve matriz de tiempo de Espera entre Estaciones para el trayecto 't' de la ruta 'r'\"\n        return self.pasajerosPuedenAbordar(r,t)[0]*self.TIEMPOABORDAR\n\n    # print np.around(self.tiempoEsperaEstaciones(0, 0), decimals =3)\n    # print np.around(self.tiempoEsperaEstaciones(0, 0).sum(axis=1), decimals =2)\n\n    def tiempoAcumuladoBajada(self, r, t):\n        \"Devuelve matriz de tiempo Acumulado de Bajada para el trayecto 't' de la ruta 'r'\"\n        tiempoEspera  = self.tiempoEsperaEstaciones(r,t)\n        mTransbordo = self._TRANSBORDOS[r][t]\n        tiempoEsperaI = 0\n        suma = np.zeros(shape=(self.NUMEROESTACIONES))\n        _tiempoBajada = np.zeros(shape=(self.NUMEROESTACIONES,self.NUMEROESTACIONES))\n        secuencia = self._SECUENCIAS[r][t]-1\n        for i, e in enumerate(secuencia):\n            if t == 0:\n                suma[e] = tiempoEspera[:e,e].sum()\n            else:\n                suma[e] = tiempoEspera[secuencia[:i],e].sum()\n                if r==2:\n                    tiempoEsperaI = self.tiempoEsperaEstaciones(r,0)\n                    secuenciaI = self._SECUENCIAS[r][0]-1\n                    if np.in1d(e, secuenciaI):\n                        suma[e] += tiempoEsperaI[secuenciaI[e:],e].sum() # Revisar\n                    else:\n                        suma[e] += tiempoEsperaI[secuenciaI,e].sum()\n            if np.in1d(e+1, mTransbordo):\n                mTransbordoB = mTransbordo == e+1\n                # print e+1\n                # print mTransbordoB\n                suma[e] += tiempoEspera[mTransbordoB].sum()\n                if r==2:\n                    tiempoEsperaI = self.tiempoEsperaEstaciones(r,0)\n                    suma[e] += tiempoEsperaI[mTransbordoB].sum()\n            if i>0 and t==0:\n                _tiempoBajada[e,secuencia[i-1]] = suma[e]\n\n        if t == 0:\n            for iS, i in enumerate(secuencia):\n                for j in range(iS+1,len(secuencia)):\n                    _tiempoBajada[secuencia[j],i] = _tiempoBajada[secuencia[j-1],i] + suma[secuencia[j]]\n            _tiempoBajada = np.transpose(_tiempoBajada)\n        else:\n            for iS, i in enumerate(secuencia):\n                for j in range(iS+1,len(secuencia)):\n                    _tiempoBajada[i,secuencia[j]] = _tiempoBajada[i,secuencia[j-1]] + suma[secuencia[j]]\n        return _tiempoBajada\n\n    # print self.tiempoAcumuladoBajada(2,0)\n    def tiempoAcumuladoSubida(self, r, t):\n        \"Devuelve matriz de tiempo Acumulado de Subida para el trayecto 't' de la ruta 'r'\"\n        tiempoEspera = self.tiempoEsperaEstaciones(r,t)\n        suma = tiempoEspera.sum(axis=1)\n        _tiempoSubida = np.zeros(shape=(self.NUMEROESTACIONES,self.NUMEROESTACIONES))\n        np.fill_diagonal(_tiempoSubida,suma)\n        secuencia = self._SECUENCIAS[r][t] -1\n        if t == 0:\n            for iS, i in enumerate(secuencia):\n                for j in range(iS+1,len(secuencia)):\n                    _tiempoSubida[secuencia[j],i] = _tiempoSubida[secuencia[j-1],i] + suma[secuencia[j]]\n            _tiempoSubida = np.transpose(_tiempoSubida)\n        else:\n            for iS, i in enumerate(secuencia):\n                for j in range(iS+1,len(secuencia)):\n                    _tiempoSubida[i,secuencia[j]] = _tiempoSubida[i,secuencia[j-1]] + suma[secuencia[j]]\n        return _tiempoSubida\n\n    # print np.around(self.tiempoAcumuladoSubida(0, 0), decimals = 2)\n\n    def tiempoViajePromedio(self, r, t):\n        '''\n        Devuelve Matriz tiempo de viaje promedio para el trayecto 't' de la ruta 'r'\n        '''\n        # print value(self.FrecuenciasOptimas[0])\n        tiempoEntreEstacionesM = self._TIEMPO_ENTRE_ESTACIONES[r]\n        tiempoEsperaPromedioM  = self.tiempoEsperaPromedio(t)\n        tiempoAcumuladoSubidaM = self.tiempoAcumuladoSubida(r,t)\n        tiempoAcumuladoBajadaM = self.tiempoAcumuladoBajada(r,t)\n        # print tiempoEsperaPromedioM\n        # print tiempoAcumuladoSubidaM\n        # print tiempoAcumuladoBajadaM\n        _tiempoViajePromedio = np.zeros(shape=(self.NUMEROESTACIONES, self.NUMEROESTACIONES))\n        secuencia = self._SECUENCIAS[r][t]-1\n        for i, ei in enumerate(secuencia):\n            for ej in secuencia[i:]:\n                _tiempoViajePromedio[ei,ej] = tiempoEntreEstacionesM[ei,ej] + tiempoEsperaPromedioM[ei,ej] + \\\n                tiempoAcumuladoSubidaM[ei,ej] + tiempoAcumuladoBajadaM[ei,ej]\n        # print _tiempoViajePromedio.sum(), model[0].value\n        return _tiempoViajePromedio\n\n    # print np.around(self.tiempoViajePromedio(2,1), decimals = 2)\n    # print np.around(self.tiempoViajePromedio(1,0).sum(axis=0), decimals = 2)\n\n    def pasajerosEspera2Viaje(self,r,t):\n        '''\n        Devuelve matriz de tiempo de espera de los pasajeros\n        para el segundo viaje para el trayecto 't' de la ruta 'r'\n        '''\n        return self.distribucionDemanda(r,t) - self.pasajerosPuedenAbordar(r,t)[0]\n\n    # print np.around(self.pasajerosEspera2Viaje(2,1), decimals=1)\n    # print np.around(self.pasajerosEspera2Viaje(2,1).sum(), decimals=1)\n\n    def tiempoEsperaPor2Bus(self, t):\n        \"Devuelve matriz de tiempo de espera por el segundo bus para el trayecto 't'\"\n        return self.tiempoEsperaPromedio(t) + self.tiempoEsperaMaximo(t)\n\n    # print np.around(self.tiempoEsperaPor2Bus(1), decimals=2)\n\n    def tiempoEsperarPor2Viaje(self,r,t):\n        '''\n        Devuelve matriz de tiempo de espera para el\n        segundo viaje para el trayecto 't' de la ruta 'r'\n        '''\n        pasajerosEspera2ViajeB = self.pasajerosEspera2Viaje(r,t)>0\n        # pasajerosE2Vmat = self.pasajerosEspera2Viaje(r,t, model)\n        # pasajerosEspera2ViajeB = np.zeros((self.NUMEROESTACIONES, self.NUMEROESTACIONES), dtype=bool)\n        # for i in range(pasajerosE2Vmat.shape[0]):\n        #     for j in range(pasajerosE2Vmat.shape[1]):\n        #         if pasajerosE2Vmat[i,j] > 0:\n        #             pasajerosEspera2ViajeB[i,j] = True\n\n        _tiempoEsperarPor2Viaje = np.where(pasajerosEspera2ViajeB, self.tiempoEsperaPor2Bus(t), 0)\n        return _tiempoEsperarPor2Viaje\n    # print np.around(self.tiempoEsperarPor2Viaje(2,1), decimals=1)\n\n    def frecuenciaTotal(self,t):\n        \"Devuelve matriz de Frecuencia Total para el segundo viaje para el trayecto 't'\"\n        _frecuenciaTotal = np.zeros(shape=(self.NUMEROESTACIONES, self.NUMEROESTACIONES))\n        # if model:\n        #     for r, f in enumerate(model):\n        #         _frecuenciaTotal += np.where(self._TOPOLOGIA[r][t]>0, model[r], 0)#value(f), 0)\n        # else:\n        for r, f in enumerate(self.FrecuenciasOptimas):\n            _frecuenciaTotal += np.where(self._TOPOLOGIA[r][t]>0, f, 0)#value(f), 0)\n        return _frecuenciaTotal\n\n    # print np.around(self.frecuenciaTotal(1), decimals=2)\n\n    def funcionCalidad(self,t):\n        '''\n        Devuelve matriz de Funcion de Calidad para el segundo viaje para el trayecto 't'\n\n        Parametros\n        ----------\n            - t: trayecto donde \"0\" es ida y \"1\" es vuelta\n\n        Return\n        ------\n            - matriz(self.NUMEROESTACIONES, self.NUMEROESTACIONES)\n\n        '''\n        return self.frecuenciaTotal(t)*self.tiempoEsperaPromedio(t)\n\n    # print np.around(self.funcionCalidad(1), decimals=2)\n\n    def serviciosRequeridos(self,r,t):\n        '''\n        Devuelve matriz de Servicios Requeridos para el\n        segundo viaje para el trayecto 't' de la ruta 'r'\n        '''\n        return self.distribucionDemanda(r,t)/self.CAPACIDADBUSES\n\n    # print np.around(self.serviciosRequeridos(1,0), decimals=2)\n\n    def flujoAsignado(self,t):\n        '''\n        Devuelve matriz de Flujo Asignado para el segundo viaje de todas las rutas en el trayecto trayecto 't'\n\n        Parametros\n        ----------\n            - t: trayecto donde \"0\" es ida y \"1\" es vuelta\n\n        Return\n        ------\n            - _flujoAsignado: matriz(self.NUMEROESTACIONES, self.NUMEROESTACIONES)\n\n        '''\n        _flujoAsignado = np.zeros(shape=(self.NUMEROESTACIONES, self.NUMEROESTACIONES))\n        for r in range(self.NUMERORUTAS):\n            _flujoAsignado += np.where(self._TOPOLOGIA[r][t]>0, self.serviciosRequeridos(r,t), 0)\n        # print self.FrecuenciasOptimas\n        return _flujoAsignado\n\n\n    def intervalosTiemposEntreSalidas(self):\n        \"Devuelve los periodos de salida de las rutas\"\n        return 1/np.array(self.FrecuenciasOptimas)\n\n    def tiempoViajePromedioSinEsperaSB(self,r,t):\n        '''\n        Matriz tiempo de viaje promedio\n        '''\n        # print value(self.FrecuenciasOptimas[0])\n        tiempoEntreEstacionesM = self._TIEMPO_ENTRE_ESTACIONES[r]\n        tiempoAcumuladoSubidaM = self.tiempoAcumuladoSubida(r,t)\n        tiempoAcumuladoBajadaM = self.tiempoAcumuladoBajada(r,t)\n        _tiempoViajePromedio = np.zeros(shape=(self.NUMEROESTACIONES, self.NUMEROESTACIONES))\n        secuencia = self._SECUENCIAS[r][t]-1\n        for i, ei in enumerate(secuencia):\n            for ej in secuencia[i:]:\n                _tiempoViajePromedio[ei,ej] = tiempoEntreEstacionesM[ei,ej] + tiempoAcumuladoSubidaM[ei,ej] + tiempoAcumuladoBajadaM[ei,ej]\n        # print _tiempoViajePromedio.sum(), model[0].value\n        return _tiempoViajePromedio\n\n    def tiempoViajePromedioSinEspera(self,r,t):\n        '''\n        Matriz tiempo de viaje promedio\n        '''\n        # print value(self.FrecuenciasOptimas[0])\n        tiempoEntreEstacionesM = self._TIEMPO_ENTRE_ESTACIONES[r]\n        _tiempoViajePromedio = np.zeros(shape=(self.NUMEROESTACIONES, self.NUMEROESTACIONES))\n        secuencia = self._SECUENCIAS[r][t]-1\n        for i, ei in enumerate(secuencia):\n            for ej in secuencia[i:]:\n                _tiempoViajePromedio[ei,ej] = tiempoEntreEstacionesM[ei,ej]\n        # print _tiempoViajePromedio.sum(), model[0].value\n        return _tiempoViajePromedio\n    \n\n    def convertHour(self, horas = None, hora = None):\n        '''\n        horas/hora es una variable que viene en segundos, esta Función\n        transforma los segundos en la clase delta.timedelta y los devuelve\n        como string\n        '''\n        if horas:\n            horasD = []\n            for i, x in enumerate(horas):\n                horasD.append(str(datetime.timedelta(seconds= int(round(((x*24)*60)*60)))))\n            # return np.vectorize(str(datetime.timedelta(minutes=x)))\n            return np.array(horasD)\n        elif hora:\n            horaStr = str(datetime.timedelta(seconds= int(round(((hora*24)*60)*60))))\n            if len(horaStr) == 7:\n                horaStr = \"0\" + horaStr\n            return horaStr\n\n\n    def horaInicioServicios(self,r):\n        '''\n        Devuelve un arreglo con las horas de inicio de cada servicio en la Ruta 'r'\n        '''\n        intervalosPeriodosRutas = self.intervalosTiemposEntreSalidas()[r]/(24*60)\n        tiempoInicio = self.HORAINICIO/24\n        tiempoFinal = self.HORAFIN/24\n        # minutosTotales = (self.HORAINICIO - self.HORAFIN)*60 # Los convertimos en minutos\n        horas = np.arange(tiempoInicio, tiempoFinal, intervalosPeriodosRutas)\n\n        # horasD = []\n        # for i, x in enumerate(horas):\n        #     horasD.append(str(datetime.timedelta(seconds= int(round(((x*24)*60)*60)))))\n        # return np.array(horasD)\n\n        return horas\n\n    def horaEstaciones(self,r,t, idT):\n        '''\n        Devuelve la linea del servicio,\n        es decir para cada estación tiene: la hora de llegada, la hora de salida,\n        dos booleanos que indican si es una estación de inicio o estación final,\n        el id del trayecto y la secuencia\n\n        Parametros\n        ----------\n            - r: Indice de Ruta\n            - t: Indice de Trayecto\n            - idT: id del Trayecto\n\n        Return\n        ------\n            - _horaEstaciones: matriz que contiene\n                               [[   * _horaEstacionesLlegada,\n                                    * _horaEstacionesSalida,\n                                    * estacionInicio,\n                                    * estacionFinal,\n                                    * idTrayecto,\n                                    * secuencia ], ...]\n\n        '''\n        horaInicio = self.horaInicioServicios(r)\n        secuencia = self._SECUENCIAS[r][t] -1\n        tiempoSalida = self.tiempoViajePromedioSinEsperaSB(r,t)[secuencia[0],secuencia] / (24*60)\n        tiempoLlegada = np.zeros(len(secuencia))\n        # tiempoLlegada[1:] = tiempoSalida[:-1] + self.tiempoViajePromedioSinEspera(r,t)[secuencia[0],secuencia[1:]] / (24*60)\n        for i in range(1,len(tiempoLlegada)):\n            tiempoLlegada[i] = tiempoSalida[i-1] + self.tiempoViajePromedioSinEspera(r,t)[secuencia[i-1],secuencia[i]] / (24*60)\n        _horaEstaciones = []\n        for horaI in horaInicio:\n            # _horaEstacionesLlegada = self.convertHour(horaI + tiempoLlegada)\n            _horaEstacionesLlegada = (horaI + tiempoLlegada)\n            # _horaEstacionesSalida = self.convertHour(horaI + tiempoSalida)\n            _horaEstacionesSalida = (horaI + tiempoSalida)\n            estacionInicio = np.zeros(len(secuencia), dtype=bool)\n            estacionInicio[0] = True\n            estacionFinal = np.zeros(len(secuencia), dtype=bool)\n            estacionFinal[-1] = True\n            idTrayecto = np.empty(len(secuencia))\n            idTrayecto.fill(idT)\n            _horaEstaciones.append(zip(_horaEstacionesLlegada, _horaEstacionesSalida, estacionInicio, estacionFinal, idTrayecto, secuencia))\n        dtype = [('horaLlegada', float), ('horaSalida', float),('estacionInicio', bool), ('estacionFinal', bool),('idTrayecto', int), ('secuencia', int)]\n        _horaEstaciones = np.array(_horaEstaciones, dtype)\n        return _horaEstaciones\n\n\n    def horasRuta(self,r):\n        '''\n        Devuelve una lista que contiene la hora inicial,\n        la hora final y el id del trayecto para la ruta \"r\"\n        '''\n        horas = []\n        rutaT = self._TRAYECTOS[r]\n        horasIda = []\n        horasVuelta = []\n        for t, value in rutaT.iteritems():\n            if value == 'Ida':\n                # horas.append(self.horaEstaciones(r,0,t))\n                for horaE in self.horaEstaciones(r,0,t):\n                    horasIda.append((horaE[0]['horaLlegada'], horaE[-1]['horaSalida'], horaE[0]['idTrayecto']))\n            else:\n                for horaE in self.horaEstaciones(r,1,t):\n                    horasVuelta.append((horaE[0]['horaLlegada'], horaE[-1]['horaSalida'], horaE[0]['idTrayecto']))\n        horas = horasIda + horasVuelta\n        dtype= [('horaInicial', float), ('horaFinal', float), ('idTrayecto', int)]\n        horas = np.array(horas, dtype)\n        # print horas.shape, r, horas\n        # horas = horas.reshape(rows*columns,horas.shape[2])\n        return horas\n\n    def serviciosRuta(self,r, horas = None):\n        '''\n            Función que recibe la ruta para la cual se van a sacar los servicios\n            Los servicios son la identificación de un determinado bus que recorre la ruta\n\n            Parametros\n            ----------\n                - r: indice de Ruta. Ej: 0 --> Ruta 1\n                - horas: Arreglo con hora inicial y final de la ruta\n\n            Return\n            ------\n                - servicios: \n\n        '''\n        if horas == None:\n            horas = self.horasRuta(r)\n        horasDict = []\n        tray = self._TRAYECTOS[r]\n        tIda = None\n        tVuelta = None\n        for key, value in tray.items():\n            if value == 'Ida':\n                tIda = key\n            else:\n                tVuelta = key\n        for ind ,hora in enumerate(horas):\n            horasDict.append((ind , hora['horaInicial'], hora['idTrayecto']))\n        dtype = [('id', int),('horaLlegada', float), ('idTrayecto', int)]\n        horasDictArray = np.array(horasDict, dtype)\n        horasDictArray.sort(order='horaLlegada')\n        pilaSalida = []\n        servicios = []\n        pilaSalida.append((0,horas[horasDictArray[0][0]]['horaFinal'], horasDictArray[0][2]))\n        servicios.append((0, horasDictArray[0][0], horasDictArray[0][1], horasDictArray[0][2]))\n        serv  = 1\n        flag = True\n        for x in horasDictArray[1:]:\n            '''\n            x[0] = id    x[1] = horaLlegada    x[2] = idTrayecto\n            '''\n            # pilaSalida.append((i,horas['horaFinal'][x[0]][-1], x[2]))\n            typeD = [('servicio', int),('horaSalida', float), ('idTrayecto', int)]\n            pilaSalidaArray = np.array(pilaSalida, typeD)\n            pilaSalidaArray.sort(order='horaSalida')\n            pilaTrayecto = pilaSalidaArray[pilaSalidaArray['idTrayecto'] != x[2]]\n            # if pilaSalidaArray[0]['horaSalida'] < x[1]:\n            if pilaTrayecto[0]['horaSalida'] < x[1] and flag:\n                serviciosV = np.array(servicios)\n                serviciosAdicionales = serviciosV[serviciosV[:,-1]==tVuelta]\n                for ind in reversed(serviciosAdicionales):\n                    servicios.insert(0, (ind[0], -1.0, 0.0, tIda))\n                servicios.append((pilaTrayecto[0]['servicio'], x[0], x[1], x[2]))\n                del pilaSalida[pilaTrayecto[0]['servicio']]\n                # pilaSalida.insert(pilaSalidaArray[0]['servicio'],(pilaSalidaArray[0]['servicio'], horas[:]['horaSalida'][x[0]][-1],x[2]))\n                pilaSalida.insert(pilaTrayecto[0]['servicio'],(pilaTrayecto[0]['servicio'], horas[x[0]]['horaFinal'],x[2]))\n                flag = False\n            elif pilaTrayecto[0]['horaSalida'] < x[1]:\n                servicios.append((pilaTrayecto[0]['servicio'], x[0], x[1], x[2]))\n                del pilaSalida[pilaTrayecto[0]['servicio']]\n                # pilaSalida.insert(pilaSalidaArray[0]['servicio'],(pilaSalidaArray[0]['servicio'], horas[:]['horaSalida'][x[0]][-1],x[2]))\n                pilaSalida.insert(pilaTrayecto[0]['servicio'],(pilaTrayecto[0]['servicio'], horas[x[0]]['horaFinal'],x[2]))\n            else:\n                pilaSalida.append((serv , horas[x[0]]['horaFinal'] , x[2]))\n                servicios.append((serv , x[0], x[1], x[2]))\n                serv +=1\n        # print len(servicios)\n        numeroServA = len(serviciosAdicionales)\n        serviciosIda = np.array(servicios)\n        serviciosIda = serviciosIda[serviciosIda[:,-1]==tIda]\n        for serv in serviciosIda[-numeroServA:]:\n            servicios.append((serv[0], -1.0, 1.0, tVuelta))\n        # print len(servicios)\n\n        # dtype = [('servicio', int), ('id', int), ('horaLlegada', float), ('idTrayecto', int)]\n        return np.array(servicios)\n\n    def serviciosOrdenados(self,r, t):\n        \"Recibe los servicios, y los devuelve con orden respecto a los servicios\"\n        serv = self.serviciosRuta(r)\n        serv = serv[serv[:,-1]==t]\n        _serviciosOrdenados = serv[np.lexsort((serv[:,2], serv[:,0]))]\n        arrayServ = []\n        length = 0\n        for i in range(int(_serviciosOrdenados[:,0].max())+1):\n            subArray = _serviciosOrdenados[_serviciosOrdenados[:,0] == i]\n            lengthA = len(subArray)\n            arrayServ.append(subArray)\n            if length < lengthA:\n                length = lengthA\n        newArray = np.empty_like(serv)\n        ind = 0\n        for i in range(length):\n            for e in arrayServ:\n                if i < len(e):\n                    newArray[ind] = e[i]\n                    ind += 1\n                # print e[i]\n        return np.array(newArray)\n        # return 0\n\n\n    def jsonFile(self, direccion = None, nombreArchivoS = None):\n        '''\n            Genera el archivo \"horarios-NOMBREARCHIVOFUENTE-.json\" con la estructura v3\n            requerida por SingleClick\n\n            Parametros\n            ----------\n                - direccion = String. Contiene la direccion de la carpeta donde se va a generar el JSON\n                                      Si se deja como vacio la direccion por defecto sera:\n                                        \"/var/www/html/Archivos/Optimizacion/Programacion/\"\n                - nombreArchivoS = String. Contiene el nombre del archivo para ser generado. Si se deja\n                                           Vacio el nombre por defecto sera el nombre de este archivo.\n                                           \"modeloOptimizacionV5\"\n\n        '''\n        estructura = []\n        tray = 0\n        # horaAnt = None\n        # print self._TRAYECTOS\n        # _serviciosRuta = None\n        for r, rutaT in enumerate(self._TRAYECTOS):\n            _serviciosRuta = self.serviciosRuta(r)\n            horaAnt = None\n            for t, value in rutaT.iteritems():\n                estructura.append({'idtrayecto':t})\n                serviciosEst = []\n                if value == 'Ida':\n                    horas = self.horaEstaciones(r,0,t)\n                    horaAnt = horas\n                else:\n                    if horaAnt == None:\n                        for key, valueD in self._TRAYECTOS[r].iteritems():\n                            if valueD == 'Ida':\n                                horaAnt = self.horaEstaciones(r,0,key)\n                    horas = self.horaEstaciones(r,1,t)\n                # print self.serviciosRuta(0)\n                # _serviciosRuta = self.serviciosOrdenados(r, t)\n                _serviciosRutaB = _serviciosRuta[_serviciosRuta[:,-1]==t]\n                for i, servicio in enumerate(_serviciosRutaB):\n                # for i, servicio in enumerate(_serviciosRuta):\n                    horarios = {}\n                    # horarios = []\n                    serviciosDict = {'idservicio':int(servicio[0])+1}\n                    if servicio[1] != -1:\n                        if value == 'Ida':\n                            idLinea = servicio[1]\n                        else:\n                            idLinea = servicio[1] - len(horaAnt)\n                        for j, hora in enumerate(horas[idLinea]):\n                            # print hora\n                            estacionesDict = {}\n                            if self.EstacionesBaseDatosDict:\n                                estacionesDict[\"idestacion\"] = self.EstacionesBaseDatosDict[hora['secuencia']+1]\n                            else:\n                                estacionesDict[\"idestacion\"] = hora['secuencia']+1\n                            estacionesDict[\"horallegada\"] = self.convertHour(hora = hora['horaLlegada'])\n                            estacionesDict[\"horasalida\"] = self.convertHour(hora = hora[\"horaSalida\"])\n                            estacionesDict[\"estacioninicial\"] = 'true' if hora[\"estacionInicio\"] else 'false'\n                            estacionesDict[\"estacionfinal\"] = 'true' if hora[\"estacionFinal\"] else 'false'\n                            horarios[str(j)] = estacionesDict\n                            # horarios.append(str(j) +\" \"+str(estacionesDict))\n                    serviciosDict[\"horarios\"] = horarios\n                    serviciosDict[\"orden\"] = i+1\n                    serviciosEst.append(serviciosDict)\n                estructura[tray]['servicios']= serviciosEst\n                tray+=1\n        path = inspect.getfile(inspect.currentframe()) \n        nombreArchivoExt = os.path.basename(path)\n        nombreArchivo, extension = os.path.splitext(nombreArchivoExt)\n        if direccion is None:\n            out_file = open(\"/var/www/html/Archivos/Optimizacion/Programacion/\"+nombreArchivoS+\".json\",\"w\")\n        else:\n            if nombreArchivoS is None:\n                out_file = open(direccion+\"/\"+nombreArchivo+\".json\",\"w\")\n            else:\n                out_file = open(direccion+\"/\"+nombreArchivoS+\".json\",\"w\")\n\n        # out_file = open(\"/etc/optimizacion/archivos/horariosOpt.json\",\"w\")\n        # out_file = open(\"/var/www/html/Archivos/Optimizacion/horariosOpt.json\",\"w\")\n        generarRegistroBD(nombreArchivo, nombreArchivoS)\n        json.dump(estructura,out_file, indent=4, sort_keys=True, separators=(',', ': '))\n        out_file.close()\n\n    def generarRegistroBD(nombreArchivo, nombreArchivoS):\n        \n\n    def objFunctionGenetic(self, frecuencias):\n        '''\n        Función objetivo utilizada en el algoritmo Genético,\n        Que devuelve el valor de la función sin escalamiento\n\n        Parametros\n        ----------\n            - frecuencias: Lista de tipo int, que contiene los indices\n                           de la lista \"self.ValoresFrecuencias\".\n        Return\n        ------\n            - (obj1 + obj2)*penalty: Devuelve el valor de la funcion objetivo total,\n                                     Que es la suma de la funcion objetivo de los pasajeros \"obj1\"\n                                     mas la suma de la funcion objetivo del operador \"obj2\"\n                                     esto multiplicado por una penalidad.\n        '''\n        # global self.FrecuenciasOptimas\n        penalty = 1\n        for i, x in enumerate(frecuencias):\n            self.FrecuenciasOptimas[i] = self.ValoresFrecuencias[x]\n            # self.FrecuenciasOptimas[i] = x\n\n        lenf = len(self.FrecuenciasOptimas)\n        obj1 = (sum(self.tiempoViajePromedio(r,t).sum() for r in range(lenf) for t in  [0,1]) +\n                (sum(self.tiempoEsperarPor2Viaje(r,t).sum() for r in range(lenf) for t in  [0,1]))*self.TIEMPOESPERA2BUS)*self.FACTORPASAJERO\n        obj2 = sum(self.COSTOS[r]* self.FrecuenciasOptimas[r] for r in range(lenf))*self.FACTOROPERADEOR\n\n        # rule = self.flujoAsignado().sum(axis=0) <= self.funcionCalidad().sum(axis=0)\n        # Restriccion, se agrega penalidad a objetivo si no se cumple\n        if not((self.flujoAsignado(0) <= self.funcionCalidad(0)).all() and (self.flujoAsignado(1) <= self.funcionCalidad(1)).all()):\n            penalty = 100\n        # vecO[frecuencias]\n        return (obj1 + obj2)*penalty\n\n    def objFunction(self, frecuencias):\n        '''\n        Devuelve el valor de la funcion Funcion objetivo utilizada en el algoritmo Nelder-Mead,\n        ya que se utilizan los valores de las Frecuencias Optimas obtenidas por el algoritmo. \n        Se requiere separar las funciones objetivo ya que la variacion y tipo de el parametro \"frecuencias\"\n        es diferente.\n\n\n        Parametros\n        ----------\n            - frecuencias: Lista de tipo float, que contiene las frecuencias\n                           actuales.\n        Return\n        ------\n            - (obj1 + obj2)*penalty: Devuelve el valor de la funcion objetivo total,\n                                     Que es la suma de la funcion objetivo de los pasajeros \"obj1\"\n                                     mas la suma de la funcion objetivo del operador \"obj2\"\n                                     esto multiplicado por una penalidad.\n\n        '''\n        # global self.FrecuenciasOptimas\n        penalty = 1\n\n        for i, x in enumerate(frecuencias):\n            # self.FrecuenciasOptimas[i] = self.ValoresFrecuencias[x]\n            if x < self.ValoresFrecuencias[-1]:\n                penalty = 1000\n                self.FrecuenciasOptimas[i] = self.ValoresFrecuencias[-1]\n            else:\n                self.FrecuenciasOptimas[i] = x\n        lenf = len(self.FrecuenciasOptimas)\n        obj1 = (sum(self.tiempoViajePromedio(r,t).sum() for r in range(lenf) for t in  [0,1]) +\n                (sum(self.tiempoEsperarPor2Viaje(r,t).sum() for r in range(lenf) for t in  [0,1]))*self.TIEMPOESPERA2BUS)*self.FACTORPASAJERO\n        obj2 = sum(self.COSTOS[r]* self.FrecuenciasOptimas[r] for r in range(lenf))*self.FACTOROPERADEOR\n\n        if not((self.flujoAsignado(0) <= self.funcionCalidad(0)).all() and (self.flujoAsignado(1) <= self.funcionCalidad(1)).all()):\n            penalty = 100\n        # vecO[frecuencias]\n        return (obj1 + obj2)*penalty\n\n    def objFunctionList(self, frecuencias = None):\n        '''\n        Funcion objetivo utilizada en el algoritmo Nelder-Mead,\n        ya que se utilizan los valores de las Frecuencias Optimas\n        obtenidas por el algoritmo\n\n        frecuencias: Lista de tipo float, que contiene las frecuencias\n        optimas\n        '''\n        # global self.FrecuenciasOptimas\n\n        if frecuencias != None:\n            for i, x in enumerate(frecuencias):\n                # self.FrecuenciasOptimas[i] = self.ValoresFrecuencias[x]\n                self.FrecuenciasOptimas[i] = x\n\n        lenf = len(self.FrecuenciasOptimas)\n        obj1 = (sum(self.tiempoViajePromedio(r,t).sum() for r in range(lenf) for t in  [0,1]) +\n                (sum(self.tiempoEsperarPor2Viaje(r,t).sum() for r in range(lenf) for t in  [0,1]))*self.TIEMPOESPERA2BUS)*self.FACTORPASAJERO\n        obj2 = sum(self.COSTOS[r]* self.FrecuenciasOptimas[r] for r in range(lenf))*self.FACTOROPERADEOR\n\n        # vecO[frecuencias]\n        return [obj1, obj2]\n\n    def gradf(self, frecuencias):\n        '''\n        Calcula la gradiente de la función objetivo a través de numpy\n        '''\n        # global self.FrecuenciasOptimas\n\n        for i, x in enumerate(frecuencias):\n            # self.FrecuenciasOptimas[i] = self.ValoresFrecuencias[x]\n            self.FrecuenciasOptimas[i] = x\n        arrayT = []\n        for r in range(len(frecuencias)):\n            obj1 = (sum(self.tiempoViajePromedio(r,t).sum() for t in  [0,1]) +\n                sum(self.tiempoEsperarPor2Viaje(r,t).sum() for t in  [0,1])*self.TIEMPOESPERA2BUS)*self.FACTORPASAJERO\n            obj2 = self.COSTOS[r]* frecuencias[r]*self.FACTOROPERADEOR\n            arrayT.append(obj1+ obj2)\n        arrayN = np.array(arrayT)\n        arrayG = np.gradient(arrayN)\n        return arrayG\n\n\n    # Genome instance\n    def optGAPyevolve(self, multiProcessing= False):\n        '''\n        Implementación de Algoritmo Genético, a través de la librería pyevolve.\n        Devuelve la lista con las frecuencias óptimas para cada ruta\n        '''\n        # Crea una lista del tamaño del Numero de Rutas\n        genome = G1DList.G1DList(len(self.FrecuenciasOptimas))\n        # parametros que varían de 0 a 24 que son los indices de los valores\n        genome.setParams(rangemin=0, rangemax=25)\n        genome.initializator.set(Initializators.G1DListInitializatorInteger)\n        genome.mutator.set(Mutators.G1DListMutatorIntegerRange)\n\n        # The evaluator function (objective function)\n        genome.evaluator.set(self.objFunctionGenetic)\n\n        # Genetic Algorithm Instance\n        ga = GSimpleGA.GSimpleGA(genome)\n\n        if multiProcessing:\n            ga.setMultiProcessing()\n\n        ga.selector.set(Selectors.GRankSelector)\n        # ga.selector.set(Selectors.GTournamentSelector)\n        # csv_adapter = DBFileCSV(identify=\"run1\", filename=\"stats.csv\")\n        # ga.setDBAdapter(csv_adapter)\n        ga.setMinimax(Consts.minimaxType[\"minimize\"])\n        ga.setGenerations(20)\n        ga.setMutationRate(0.1)\n        # ga.terminationCriteria.set(GSimpleGA.RawScoreCriteria)\n\n        # print Initializators.G1DListInitializatorReal\n        # Do the evolution, with stats dump\n        # frequency of 10 generations\n        ga.evolve(freq_stats=5)\n\n        # # Best individual\n        best = ga.bestIndividual()\n        # print best\n        # print [self.ValoresFrecuencias[x] for x in best.genomeList]\n        frecuencias = np.copy(self.FrecuenciasOptimas)\n        for i, g in enumerate(best.genomeList):\n            frecuencias[i] = self.ValoresFrecuencias[g]\n\n        print \"\\nFuncion objetivo Genetico: %.2f\"% (best.score,), \\\n        \", Frecuencias: \", np.around(frecuencias, decimals = 4)\n\n        objetivos = self.objFunctionList(frecuencias)\n        print \"Objetivo Pasajeros: \" + str(objetivos[0])+\" Objetivo Operador: \" + str(objetivos[1])\n        return frecuencias\n\n    def optNelderMead(self, multiProcessing = False):\n        '''\n        Función que cambia las variables de las self.FrecuenciasOptimas # global\n        utilizando el algoritmo Nelder-Mead de la librería SciPy\n        Nelder-Mead: nonlinear optimization technique\n        '''\n        # global self.FrecuenciasOptimas\n        x0 = np.array(self.optGAPyevolve(multiProcessing))\n\n        # x0 = np.asarray((0.18, 0.11, 0.12))\n        # resultado = optimize.minimize(self.objFunction, x0, method = 'Nelder-Mead',\n        #                options={'disp': False})\n        resultado = optimize.fmin(self.objFunction, x0)\n        print \"\\nFuncion Objetivo Nelder-Mead: %.2f\"%(self.objFunction(resultado)),\n        print ', Frecuencias : ', #np.around(resultado.x, decimals= 4)\n        self.FrecuenciasOptimas = resultado\n        # frecuencias = []\n        for i, x in enumerate(resultado):\n            # self.FrecuenciasOptimas[i] = x\n            # frecuencias.append(x)\n            print x,\n        # self.FrecuenciasOptimas = frecuencias\n\n        objetivos = self.objFunctionList(self.FrecuenciasOptimas)\n        print \"\\nObjetivo Pasajeros: \" + str(objetivos[0])+\" Objetivo Operador: \" + str(objetivos[1])\n\n    def trayectosValueF(self, secuencias):\n        '''\n            Transpone la matriz de secuencias y pasa de indices iniciando en 1 a 0\n            ej: [[1,2,3,10,15],...] ---> [[0,1,2,9,14],...]\n\n            Parametros\n            ----------\n                - secuencias: Matriz que contiene las secuencias de cada ruta\n                              [[ida,vuelta], # Ruta 1\n                                ...        , # Ruta n\n                              ]\n            Return\n            ------\n                - trayectosValue: Matriz transpuesta de secuencias\n                                  [[ruta 1,...,ruta n], # Trayecto 1\n                                    ...               , # Trayecto 2\n                                  ]\n                              \n        '''\n        trayectosValue = map(list, zip(*secuencias))\n        for tray in range(len(trayectosValue)):\n            for ruta in range(len(trayectosValue[0])):\n                trayectosValue[tray][ruta] = list(trayectosValue[tray][ruta] -1)\n        return trayectosValue\n\n    def calcularTopologiaTiempo(self):\n        '''\n            Cambia las matrices de self._TIEMPO_ENTRE_ESTACIONES y self._TOPOLOGIA, de acuerdo a las \n            self._SECUENCIAS establecidas \n\n            Parametros\n            ----------\n                None\n\n            Return\n            ------\n                - trayectosValue: Matriz transpuesta de secuencias\n                                  [[ruta 1,...,ruta n], # Trayecto 1\n                                    ...               , # Trayecto 2\n                                  ]\n        '''\n        # global self._TIEMPO_ENTRE_ESTACIONES\n        # global self._TOPOLOGIA\n        trayectosValue = self.trayectosValueF(self._SECUENCIAS)\n        tiemposTrayectos = self.tiempoTrayectosTransbordo(trayectosValue)\n        self._TIEMPO_ENTRE_ESTACIONES = self.tiempoTrayectosRutas(tiemposTrayectos)\n        self._TOPOLOGIA = self.obtenerTopologias(self._TIEMPO_ENTRE_ESTACIONES)\n\n#Se ejecuta la optimización con Algorítmos Geneticos y luego el NelderMead\n\nif __name__ == \"__main__\":\n    optimizacionF = OptimizacionFrecuencias(numeroDemanda = 2)\n    optimizacionF.obtenerDatosBase( \n        db_host =  'localhost',\n        usuario = 'optimizacion',\n        clave =  'fdoq9zSyfSlMsyW9wGkh',\n        base_de_datos = 'rutamega_principal',\n    )\n    # optimizacionF.obtenerDatosBase()\n    # optimizacionF.generarCSV()\n    optimizacionF.calcularTopologiaTiempo()\n    # print optimizacionF._TRANSBORDOS\n    optimizacionF.optNelderMead(multiProcessing = True)\n  \n    print \"\\nFactor Operador: \", optimizacionF.FACTOROPERADEOR, \" Factor Pasajero: \", optimizacionF.FACTORPASAJERO\n    print \"Demanda: \", optimizacionF.NUMERODEMANDA, \" Costos: \", optimizacionF.COSTOS\n\n    # Se ejecuta la función que genera el archivo JSON, se toma el primer parametro como el nombre de archivo.\n    # Ejemplo: > python modeloOptimizacionV5.py horariosOpt. El nombre del archivo seria horariosOpt.json\n    optimizacionF.jsonFile(nombreArchivoS = sys.argv[1])\n\n",
			"file": "modeloOptimizacionV5.py",
			"file_size": 96376,
			"file_write_time": 130741894523460649,
			"settings":
			{
				"buffer_size": 96325,
				"line_ending": "Unix",
				"name": "modeloOptimizacionV5.py"
			}
		},
		{
			"file": "/home/rafapinzon/MEGA/U/Progra/Python/databases.py",
			"settings":
			{
				"buffer_size": 2007,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/rafapinzon/MEGA/U/Progra/Python/MyNewGUI/baseDatosDialog.py",
			"settings":
			{
				"buffer_size": 6951,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "Packages/Python/Python.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Anaconda Python Builder",
					""
				],
				[
					"Packages/Python/Python.sublime-build",
					""
				],
				[
					"Packages/Python/Python.sublime-build",
					"Syntax Check"
				]
			],
			[
				"Packages/Python/Python.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 266.0,
		"last_filter": "pyth",
		"selected_items":
		[
			[
				"pyth",
				"Set Syntax: Python"
			],
			[
				"pyt",
				"Set Syntax: Python"
			],
			[
				"pytho",
				"Set Syntax: Python (Django)"
			],
			[
				"disable",
				"Package Control: Disable Package"
			],
			[
				"python",
				"Set Syntax: Python"
			],
			[
				"enabl",
				"Package Control: Enable Package"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"enable",
				"Package Control: Enable Package"
			],
			[
				"remove",
				"Package Control: Remove Package"
			],
			[
				"packa",
				"Package Control: Remove Package"
			],
			[
				"DISABLE",
				"Package Control: Disable Package"
			],
			[
				"package",
				"Package Control: Remove Package"
			],
			[
				"disabl",
				"Package Control: Disable Package"
			],
			[
				"INSTALL ",
				"Package Control: Install Package"
			]
		],
		"width": 435.0
	},
	"console":
	{
		"height": 139.0,
		"history":
		[
			"view.settings().get(\"setting_name\")",
			"view.settings()",
			"view.settings().get(\"setting_name\")",
			"import urllib.request,os,hashlib; h = '2deb499853c4371624f5a07e27c334aa' + 'bf8c4e67d14fb0525ba4f89698a6d7e1'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) "
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/Extras",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion"
	],
	"file_history":
	[
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/archivos/horariosOpt-modeloOptimizacionV5-.json",
		"/home/rafapinzon/MEGA/U/Progra/Python/MyNewGUI/GUI_App.py",
		"/home/rafapinzon/MEGA/U/Progra/Python/Python GUI Development with Qt Tutorial/PrimeraApp.py",
		"/home/rafapinzon/.config/sublime-text-3/Packages/User/Preferences.sublime-settings",
		"/home/rafapinzon/.config/sublime-text-3/Packages/User/Python.sublime-settings",
		"/home/rafapinzon/MEGA/U/Progra/Python/Python GUI Development with Qt Tutorial/05TutorialInterfazBasica.py",
		"/home/rafapinzon/Downloads/Pyevolve-0.6rc1/pyevolve/GPopulation.py",
		"/home/rafapinzon/Downloads/Pyevolve-0.6rc1/pyevolve/FunctionSlot.py",
		"/home/rafapinzon/CompilPython/mpascal/mpasparse.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/modeloOptimizacionV2.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/modelo.sublime-project",
		"/home/rafapinzon/.config/sublime-text-3/Packages/User/Python Django.sublime-settings",
		"/home/rafapinzon/.config/sublime-text-3/Packages/User/Anaconda.sublime-settings",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/modeloOptimizacionV4.1.py",
		"/home/rafapinzon/.config/sublime-text-3/Packages/User/Package Control.sublime-settings",
		"/home/rafapinzon/.config/sublime-text-3/Packages/User/JSON.sublime-settings",
		"/home/rafapinzon/.config/sublime-text-2/Packages/Default/Preferences.sublime-settings",
		"/home/rafapinzon/.config/sublime-text-3/Packages/Anaconda/Anaconda.sublime-settings",
		"/home/rafapinzon/.config/sublime-text-2/Packages/Default/Preferences (Linux).sublime-settings",
		"/home/rafapinzon/VRS/project_rs/templates/core/test/test_table.html",
		"/home/rafapinzon/VRS/project_rs/templates/core/genetic.html",
		"/home/rafapinzon/VRS/project_rs/local_apps/core/views/GeneticView.py",
		"/home/rafapinzon/VRS/project_rs/local_apps/core/urls.py",
		"/home/rafapinzon/VRS/project_rs/templates/base.html",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/Extras/DatosCreacionTiempo40est.txt",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/Extras/tiempo40EstacionesV2.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/modeloOptimizacionV4.py",
		"/home/rafapinzon/MEGA/U/Progra/Python/Python GUI Development with Qt Tutorial/tutorial6_dialogs.py",
		"/home/rafapinzon/MEGA/U/Progra/Python/Python GUI Development with Qt Tutorial/tutorial5_signals.py",
		"/home/rafapinzon/MEGA/U/Progra/Python/Python GUI Development with Qt Tutorial/tutorial4_events.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/VersionesPasadas/modeloOptimizacion.py",
		"/home/rafapinzon/VRS/project_rs/local_apps/core/models/MappModel.py",
		"/home/rafapinzon/VRS/project_rs/local_apps/core/views/TestView.py",
		"/home/rafapinzon/MEGA/U/Progra/Python/csvtutorial.py",
		"/home/rafapinzon/MEGA/U/Progra/Python/pyqt4table_example.py",
		"/home/rafapinzon/MEGA/U/Progra/Python/pyqt4file.py",
		"/home/rafapinzon/VRS/project_rs/local_apps/core/classes/MappWrapper.py",
		"/home/rafapinzon/MEGA/U/Progra/Python/MyNewGUI/gui_python.py",
		"/home/rafapinzon/MEGA/U/Progra/Python/MyNewGUI/csv_module_pyqt4.py",
		"/home/rafapinzon/MEGA/U/Progra/Python/MyNewGUI/python_widget_ui.py",
		"/home/rafapinzon/MEGA/U/Progra/Python/tut3PyQt.py",
		"/home/rafapinzon/MEGA/U/Progra/Python/Python GUI Development with Qt Tutorial/tutorial3_currency_converter.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/Soluciones/pruebas_modeloOptimizacionV4.1(variando demandas y factores).txt",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/Extras/pruebas con restriccion mala.txt",
		"/home/rafapinzon/MEGA/U/Progra/Python/MyNewGUI/csvtutorial.py",
		"/home/rafapinzon/MEGA/U/Progra/Python/MyNewGUI/untitled.ui",
		"/home/rafapinzon/CompilPython/mpascal/mpaslex.py",
		"/home/rafapinzon/CompilPython/mpascal/mpasast.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/Extras/xdlrExample.py",
		"/home/rafapinzon/blabla.py",
		"/home/rafapinzon/.config/sublime-text-3/Packages/Anaconda/README.md",
		"/home/rafapinzon/VRS/project_rs/local_apps/core/views/MapView.py",
		"/home/rafapinzon/VRS/project_rs/templates/core/mapp/costs.html",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/Extras/tiempo40Estaciones.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/modeloOptimizacionV1.py",
		"/home/rafapinzon/VRS/project_rs/local_apps/core/classes/SimAnn.py",
		"/home/rafapinzon/Dropbox/U/Progra/Python/TryExceptTut.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/Documentos/IdsEstacionesTrayectoRuta2.txt",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/Documentos/trayectos2ruta.cvs",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/Extras/Secuencias40Est.txt",
		"/home/rafapinzon/Documents/Chat/Chat/cliente.py",
		"/home/rafapinzon/Dropbox/U/Progra/Python/qtTutorial.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/modeloOptimizacionV3.py",
		"/home/rafapinzon/Documents/Chat/Chat/Server.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/Extras/EscogenciaTiemposTransbordoRutaFantasma.txt",
		"/home/rafapinzon/VRS/project_rs/local_apps/core/forms/MappForm.py",
		"/home/rafapinzon/Dropbox/U/Progra/untitled.c",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/Extras/tiempos.csv",
		"/home/rafapinzon/.config/sublime-text-3/Packages/User/Default (Linux).sublime-keymap",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/Extras/TiemposRuta2Alg.py",
		"/home/rafapinzon/Dropbox/StuffsToDo",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/ErrorServerUne.txt",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/Documentos/EstacionesRuta2.txt",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/modeloOptimizacionGA2.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/modeloOptimizacionDB1.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/archivos/horariosOpt.json",
		"/home/rafapinzon/VRS/project_rs/templates/core/test/test.html",
		"/home/rafapinzon/Dropbox/U/Progra/Python/NameFileExecuted.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/horariosOpt.json",
		"/home/rafapinzon/VRS/project_rs/templates/core/mapp/update_gmap.html",
		"/home/rafapinzon/Dropbox/Proyecto Optimización/GenerarControl.py",
		"/home/rafapinzon/Dropbox/U/Progra/Python/testPYQT.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/Test.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/modeloOptimizacionGA1.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/modeloOptimizacionDB.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/Tablas(frecuencias 0,14237 0,07289 0,15171)",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/Pruebas.txt",
		"/home/rafapinzon/Dropbox/Proyecto Optimización/Richard/GenerarControl.py",
		"/home/rafapinzon/Dropbox/U/Bases de Datos/modeloER/diagramaER.htm",
		"/home/rafapinzon/Dropbox/U/Administracion Proyectos de Software/PROYECTOS Y PLANEACION ESTRATEGICA.docx",
		"/home/rafapinzon/VRS/project_rs/rs/settings.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/PruebaModelo.dat",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/PruebaModelo.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/Estructura Json Frecuencias_v3.json",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/horarios.json",
		"/home/rafapinzon/Dropbox/Proyecto Optimización/Richard/GenerarControlconoptreal.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/modeloOptimizacionPyomo.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/modeloOptimizacion.py",
		"/home/rafapinzon/Dropbox/U/Sistemas Distribuidos/Threading.py",
		"/home/rafapinzon/Dropbox/U/Sistemas Distribuidos/Server.py",
		"/home/rafapinzon/Dropbox/U/Sistemas Distribuidos/Client.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/modeloOptimizacionGA.py",
		"/home/rafapinzon/Dropbox/Proyecto Optimización/Richard/GenerarControl organizada con problemas.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/modeloOptimizacionPyomo.dat",
		"/home/rafapinzon/Downloads/ply-3.4/AnaLexico-1.py",
		"/tmp/.fr-qnJfqu/ply-3.4/AnaLexico-1.py",
		"/home/rafapinzon/Downloads/Estructura Json Frecuencias_v2.txt",
		"/home/rafapinzon/Downloads/AnaLexico.py",
		"/home/rafapinzon/Dropbox/Proyecto Optimización/Richard/Excelexample.py",
		"/home/rafapinzon/Dropbox/U/Compiladores/pruebas.py",
		"/home/rafapinzon/Dropbox/U/Compiladores/Pruebas.pas",
		"/home/rafapinzon/Dropbox/Proyecto Optimización/json.py",
		"/home/rafapinzon/Dropbox/U/Progra/Python/databases.py",
		"/home/rafapinzon/Dropbox/ProyectoMegaBusR/ProyectoOptimizacion/tutorial.py",
		"/home/rafapinzon/Downloads/CoinIpopt/ThirdParty/Lapack/get.Lapack",
		"/home/rafapinzon/Dropbox/Proyecto Optimización/RafaStuff/modeloOptimizacion.py",
		"/home/rafapinzon/VRS/lib/python2.7/site-packages/setuptools/tests/test_resources.py",
		"/home/rafapinzon/VRS/include/python2.7/traceback.h",
		"/home/rafapinzon/VRS/lib/python2.7/site-packages/django/contrib/admin/static/admin/js/timeparse.js",
		"/home/rafapinzon/VRS/lib/python2.7/site-packages/django/contrib/gis/tests/data/invalid/emptypoints.dbf",
		"/home/rafapinzon/VRS/include/python2.7/timefuncs.h",
		"/home/rafapinzon/VRS/lib/python2.7/site-packages/setuptools/tests/test_easy_install.py",
		"/home/rafapinzon/VRS/lib/python2.7/site-packages/setuptools/tests/test_dist_info.py",
		"/home/rafapinzon/VRS/project_rs/TODO.txt",
		"/home/rafapinzon/VRS/project_rs/local_apps/core/views/SimAnnView.py",
		"/home/rafapinzon/VRS/project_rs/local_apps/core/views/UtilsView.py",
		"/home/rafapinzon/VRS/project_rs/prueba.py",
		"/home/rafapinzon/VRS/project_rs/templates/core/home.html"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 100.0,
		"where_history":
		[
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"parent",
			"()\n",
			"QtCore.QObject.connect(self.ui.buttonBoxOkCancel, QtCore.SIGNAL('accpeted()'), self.cambiarVariables)",
			"obtenerDBGUI",
			"factorPasajero",
			"FACTORPASAJER",
			"factorPasajer",
			"horaInicio",
			"lineEditDemanda",
			"optimizar",
			"self",
			"factorPasajero",
			"lineEditFactorPasajero",
			"optimizacionF",
			"0",
			"factorPasajero",
			"lineEditTiempoAbordar",
			"capacidadBuses",
			"lineEditCapacidadBuses",
			"factorOperador",
			"lineEditFactorOperador",
			"transbordos()[",
			"transbordos()",
			"is not",
			"TIEMPOABORDAR",
			"tiempoAbordar",
			"numeroEstaciones",
			"# Se sacará de base de datos",
			"slef",
			"displayPrevious",
			"MiFormulario",
			"TRANSBORDO",
			"global",
			"self",
			"calcularTopologiaTiempo",
			"trayectosValueF",
			"optNelderMead",
			"optGAPyevolve",
			"gradf",
			"objFunctionList",
			"objFunction",
			"objFunctionGenetic",
			"jsonFile",
			"serviciosOrdenados",
			"serviciosRuta",
			"horasRuta",
			"horaEstaciones",
			"horaInicioServicios",
			"convertHour",
			"tiempoViajePromedioSinEspera",
			"tiempoViajePromedioSinEsperaSB",
			"intervalosTiemposEntreSalidas",
			"flujoAsignado",
			"serviciosRequeridos",
			"funcionCalidad",
			"frecuenciaTotal",
			"tiempoEsperarPor2Viaje",
			"tiempoEsperaPor2Bus",
			"pasajerosEspera2Viaje",
			"tiempoViajePromedio",
			"tiempoAcumuladoSubida",
			"tiempoAcumuladoBajada",
			"tiempoEsperaEstaciones",
			"pasajerosPuedenAbordar",
			"pasajerosEstaValid",
			"pasajerosEstacion",
			"distribucionDemanda",
			"probabilidadEleccion",
			"matrizDemandaMedia",
			"tiempoEsperaPromedioTot",
			"tiempoEsperaPromedio",
			"demandaMediaConstante",
			"tiempoEsperaMaximoTot",
			"topologiaTot",
			"tiempoEsperaMaximo",
			"transbordos",
			"mejoresSecuencias",
			"tiempoEntreEstaciones",
			"numeroEstaciones",
			"obtenerTopologias",
			"tiempoTrayectosRutas",
			"tiempoTrayectosTransbordo",
			"tiempoTrayectosDirectos",
			"EsRutasFantasmas",
			"EsRutaFantasma",
			"_TRAYECTOS",
			"_PROPORCIONES",
			"EsRutasFantasmas",
			"FinTrayectoArray",
			"EstacionesBaseDatosDict",
			"NUMEROESTACIONES",
			"_TRANSBORDOS",
			"_SECUENCIAS",
			"_TOPOLOGIA",
			"_TiempoDirectoTrayectos",
			"_TIEMPO_ENTRE_ESTACIONES",
			"FrecuenciasOptimas",
			"COSTOS",
			"ValoresFrecuencias",
			"NUMERORUTAS",
			"HORAFIN",
			"HORAINICIO",
			"NUMERODEMANDA",
			"TIEMPOESPERA2BUS",
			"TIEMPOABORDAR",
			"CAPACIDADBUSES",
			"FACTOROPERADEOR",
			"FACTORPASAJERO",
			"tab",
			"tabs",
			"file",
			"fileName",
			"open",
			"spinbox",
			"*args, **kwargs",
			"int",
			"float",
			"int",
			"0",
			"columnView",
			"ColumnView",
			"columnView",
			"11[\\r*\\n+]",
			"11\n",
			"- GESTIÓN DE LOS RIESGOS DEL PROYECTO",
			"31211 - GESTIÓN DE LOS RIESGOS DEL PROYECTO\n",
			"",
			"^[^\\#\\n]( )+print"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"self.TRANSBORDO",
			"# global",
			"self.calcularTopologiaTiempo",
			"self.trayectosValueF",
			"self.optNelderMead",
			"self.optGAPyevolve",
			"self.gradf",
			"self.objFunctionList",
			"self.objFunction",
			"self.objFunctionGenetic",
			"self.jsonFile",
			"self.serviciosOrdenados",
			"self.serviciosRuta",
			"self.horasRuta",
			"self.horaEstaciones",
			"self.horaInicioServicios",
			"self.convertHour",
			"self.tiempoViajePromedioSinEspera",
			"self.tiempoViajePromedioSinEsperaSB",
			"self.intervalosTiemposEntreSalidas",
			"self.flujoAsignado",
			"self.serviciosRequeridos",
			"self.funcionCalidad",
			"self.frecuenciaTotal",
			"self.tiempoEsperarPor2Viaje",
			"self.tiempoEsperaPor2Bus",
			"self.pasajerosEspera2Viaje",
			"self.tiempoViajePromedio",
			"self.tiempoAcumuladoSubida",
			"self.tiempoAcumuladoBajada",
			"self.tiempoEsperaEstaciones",
			"self.pasajerosPuedenAbordar",
			"self.pasajerosEstacionValida",
			"self.pasajerosEstacion",
			"self.distribucionDemanda",
			"self.probabilidadEleccion",
			"self.matrizDemandaMedia",
			"self.tiempoEsperaPromedioTot",
			"self.tiempoEsperaPromedio",
			"self.demandaMediaConstante",
			"self.tiempoEsperaMaximoTot",
			"self.topologiaTot",
			"self.tiempoEsperaMaximo",
			"self.transbordos",
			"self.mejoresSecuencias",
			"self.tiempoEntreEstaciones",
			"self.numeroEstaciones",
			"self.obtenerTopologias",
			"self.tiempoTrayectosRutas",
			"self.tiempoTrayectosTransbordo",
			"self.tiempoTrayectosDirectos",
			"self._TRAYECTOS",
			"self._PROPORCIONES",
			"self.EsRutasFantasmas",
			"self.FinTrayectoArray",
			"self.EstacionesBaseDatosDict",
			"self.NUMEROESTACIONES",
			"self._TRANSBORDOS",
			"self._SECUENCIAS",
			"self._TOPOLOGIA",
			"self._TiempoDirectoTrayectos",
			"self._TIEMPO_ENTRE_ESTACIONES",
			"self.FrecuenciasOptimas",
			"self.COSTOS",
			"self.ValoresFrecuencias",
			"self.NUMERORUTAS",
			"self.HORAFIN",
			"self.HORAINICIO",
			"self.NUMERODEMANDA",
			"self.TIEMPOESPERA2BUS",
			"self.TIEMPOABORDAR",
			"self.CAPACIDADBUSES",
			"self.FACTOROPERADEOR",
			"self.FACTORPASAJERO",
			"TRANSBORDO",
			"10"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 12,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "modeloOptimizacionV4.1.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 82889,
						"regions":
						{
						},
						"selection":
						[
							[
								61056,
								61056
							]
						],
						"settings":
						{
							"syntax": "Packages/Djaneiro/Syntaxes/Python Django.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 22706.0,
						"zoom_level": 1.0
					},
					"stack_index": 14,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "/home/rafapinzon/Downloads/Pyevolve-0.6rc1/pyevolve/GSimpleGA.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 28674,
						"regions":
						{
						},
						"selection":
						[
							[
								14159,
								14159
							]
						],
						"settings":
						{
							"syntax": "Packages/Djaneiro/Syntaxes/Python Django.tmLanguage",
							"tab_size": 3,
							"translate_tabs_to_spaces": true
						},
						"translation.x": -0.0,
						"translation.y": 702.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "/home/rafapinzon/Downloads/Pyevolve-0.6rc1/pyevolve/GPopulation.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13859,
						"regions":
						{
						},
						"selection":
						[
							[
								4514,
								4514
							]
						],
						"settings":
						{
							"syntax": "Packages/Djaneiro/Syntaxes/Python Django.tmLanguage",
							"tab_size": 3,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 59.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "/home/rafapinzon/MEGA/U/Progra/Python/Python GUI Development with Qt Tutorial/Tutorial5InterfazBasica.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1775,
						"regions":
						{
						},
						"selection":
						[
							[
								346,
								346
							]
						],
						"settings":
						{
							"syntax": "Packages/Djaneiro/Syntaxes/Python Django.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "/home/rafapinzon/MEGA/U/Progra/Python/Python GUI Development with Qt Tutorial/SumarApp.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 851,
						"regions":
						{
						},
						"selection":
						[
							[
								444,
								444
							]
						],
						"settings":
						{
							"auto_name": "SumarApp.py",
							"syntax": "Packages/Python/Python.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "/home/rafapinzon/MEGA/U/Progra/Python/MyNewGUI/GUI_App.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4927,
						"regions":
						{
						},
						"selection":
						[
							[
								1350,
								1350
							]
						],
						"settings":
						{
							"syntax": "Packages/Djaneiro/Syntaxes/Python Django.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1123.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "/home/rafapinzon/MEGA/U/Progra/Python/MyNewGUI/GUI_App_Threads.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5788,
						"regions":
						{
						},
						"selection":
						[
							[
								2396,
								2396
							]
						],
						"settings":
						{
							"syntax": "Packages/Djaneiro/Syntaxes/Python Django.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 486.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "archivos/horariosOpt-modeloOptimizacionV5.py-.json",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1162424,
						"regions":
						{
						},
						"selection":
						[
							[
								1162115,
								1162115
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JSON.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 521957.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "/home/rafapinzon/MEGA/U/Progra/Python/Python GUI Development with Qt Tutorial/AppMultipleWindows.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2177,
						"regions":
						{
						},
						"selection":
						[
							[
								722,
								722
							]
						],
						"settings":
						{
							"syntax": "Packages/Djaneiro/Syntaxes/Python Django.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 159.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "/home/rafapinzon/MEGA/U/Progra/Python/Python GUI Development with Qt Tutorial/tutorialSumar.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2818,
						"regions":
						{
						},
						"selection":
						[
							[
								2004,
								2004
							]
						],
						"settings":
						{
							"syntax": "Packages/Djaneiro/Syntaxes/Python Django.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": -0.0,
						"translation.y": 172.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "/home/rafapinzon/MEGA/U/Progra/Python/Python GUI Development with Qt Tutorial/frameMultipleWindow.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5590,
						"regions":
						{
						},
						"selection":
						[
							[
								5338,
								5338
							]
						],
						"settings":
						{
							"syntax": "Packages/Djaneiro/Syntaxes/Python Django.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 5.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "/home/rafapinzon/MEGA/U/Progra/Python/MyNewGUI/GUIframework.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 15088,
						"regions":
						{
						},
						"selection":
						[
							[
								225,
								225
							]
						],
						"settings":
						{
							"syntax": "Packages/Djaneiro/Syntaxes/Python Django.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2118.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "modeloOptimizacionV5.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 96325,
						"regions":
						{
						},
						"selection":
						[
							[
								84512,
								84512
							]
						],
						"settings":
						{
							"auto_name": "modeloOptimizacionV5.py",
							"syntax": "Packages/Djaneiro/Syntaxes/Python Django.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 28810.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "/home/rafapinzon/MEGA/U/Progra/Python/databases.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2007,
						"regions":
						{
						},
						"selection":
						[
							[
								1318,
								1318
							]
						],
						"settings":
						{
							"syntax": "Packages/Djaneiro/Syntaxes/Python Django.tmLanguage",
							"tab_size": 3,
							"translate_tabs_to_spaces": true
						},
						"translation.x": -0.0,
						"translation.y": 216.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "/home/rafapinzon/MEGA/U/Progra/Python/MyNewGUI/baseDatosDialog.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6951,
						"regions":
						{
						},
						"selection":
						[
							[
								919,
								919
							]
						],
						"settings":
						{
							"syntax": "Packages/Djaneiro/Syntaxes/Python Django.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 982.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 35.0
	},
	"input":
	{
		"height": 36.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.anaconda_documentation":
	{
		"height": 122.0
	},
	"output.exec":
	{
		"height": 132.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "modelo.sublime-project",
	"replace":
	{
		"height": 66.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"Package Control Messages"
			],
			[
				"d",
				"def sol"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 234.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
